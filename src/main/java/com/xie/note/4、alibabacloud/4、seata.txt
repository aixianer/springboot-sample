是什么
    Seata是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。
    致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。
Seata架构
    TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。
    TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。
    RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。
四种方案
    XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入
    TCC模式：最终一致的分阶段事务模式，有业务侵入
    AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式
    SAGA模式：长事务模式，有业务侵入

    XA：
        XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，
        XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。
        两阶段提交
        步骤：
            RM一阶段的工作：

                注册分支事务到TC
                执行分支业务sql但不提交
                报告执行状态到TC
            TC二阶段的工作：
                TC检测各分支事务执行状态
                如果都成功，通知所有RM提交事务
                如果有失败，通知所有RM回滚事务
            RM二阶段的工作：
                接收TC指令，提交或回滚事务
        其他表
            UNDO_LOG
        优点：
            尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。
        缺点：
            单点问题：
                事务管理器是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。
                （XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题）
            同步阻塞：
                XA协议遵循强一致性。
                在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。
            数据不一致：
                在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。


    AT：
        AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。
        阶段一RM的工作：
            注册分支事务
            记录undo-log（数据快照）
            执行业务sql并提交
            报告事务状态
        阶段二提交时RM的工作：
            删除undo-log即可
        阶段二回滚时RM的工作：
            根据undo-log恢复数据到更新前
    TCC:
        TCC模式原理
            TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：
                Try：尝试执行,完成所有业务检查（一致性），资源的检测和预留；
                Confirm：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。
                Cancel：取消执行，释放Try阶段预留的业务资源，Cancel操作满足幂等性并且Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。
        TCC的空回滚和业务悬挂
             当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是空回滚。
             对于已经空回滚的业务，如果以后继续执行try，就永远不可能confirm或cancel，这就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂。
             Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。
        优缺点：
            优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。
            缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理
    Saga：
        长时间运行的事务,由一系列的本地事务构成。
        每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发Saga中的下一个本地事务的执行。
        如果一个本地事务因为某些业务规则无法满足而失败，Saga会执行在这个失败的事务之前成功提交的所有事务的补偿操作。
        实现方式：
            事件的方式：
                这种方式没有协调中心，第一个服务执行完本地事务之后，会产生一个事件。其它服务会监听这个事件，触发该服务本地事务的执行，并产生新的事件。
                优缺点：
                    优点：简单且容易理解。各参与方相互之间无直接沟通，完全解耦。这种方式比较适合整个分布式事务只有2-4个步骤的情形。
                    缺点：这种方式如果涉及比较多的业务参与方，则比较容易失控。各业务参与方可随意监听对方的消息，以至于最后没人知道到底有哪些系统在监听哪些消息。更悲催的是，这个模式还可能产生环形监听，也就是两个业务方相互监听对方所产生的事件。
            命令的方式：
                我们会定义一个新的服务，我们管这个新服务叫做协调中心。协调中心通过命令/回复的方式来和Saga中其它服务进行交互。
                优点：
                    避免了业务方之间的环形依赖（通过协调中心处理，不会直接面对面）。
                    将分布式事务的管理交由协调中心管理，协调中心对整个逻辑非常清楚。
                    减少了业务参与方的复杂度。这些业务参与方不再需要监听不同的消息，只是需要响应命令并回复消息。
                    测试更容易（分布式事务逻辑存在于协调中心，而不是分散在各业务方）。
                    回滚也更容易。
                缺点：
                    一个可能的缺点就是需要维护协调中心，而这个协调中心并不属于任何业务方。
                    Saga模式很难调试，特别是涉及许多微服务时。此外，如果系统变得复杂，事件消息可能变得难以维护。Saga模式的另一个缺点是它没有读取隔离。例如，客户可以看到正在创建的订单，但在下一秒，订单将因补偿交易而被删除。

        解决方式
            一阶段：直接提交本地事务
            二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚
        优点
            事务参与者可以基于事件驱动实现异步调用，吞吐高
            一阶段直接提交事务，无锁，性能好
            不用编写TCC中的三个阶段，实现简单
        缺点：
            软状态持续时间不确定，时效性差
            没有锁，没有事务隔离，会有脏写



@GlobalTransactional和@Transactional(rollbackFor = Exception.class)应用
    只用@Transactional
        开启本地事务，对本地事务进行支持。
        如果用了@Transactional则保证a、b、c操作都在同一个本地事务中执行，并且更新时会加行锁，如果本地事务不统一提交，其他SQL不能再更新此条数据。
        如果不加@Transactional则默认没有事务a、b、c操作分别执行，不会加行锁，其他SQL都可以随便更新。
    只用@GlobalTransactional
        开启全局事务，保证分布式事务。
        如果只用@GlobalTransactional，那就保证分布式事务，各个分支事务（本地事务）的统一，但是不能保证各个分支事务（本地事务）操作的统一。
        各个本地操作在无事务的状态下执行操作，不会加锁，别的操作可以随意修改。
    @GlobalTransactional和@Transactional一起用
        @Transactional保证本地事务一致性
        @GlobalTransactional保证全局事务的一致性。



扩展：
    事务ACID原则
        原子性：事务中的所有操作，要么全部成功，要么全部失败
        一致性：要保证数据库内部完整性约束、声明性约束?
        隔离性：对同一资源操作的事务不能同时发生
        持久性：对数据库做的一切修改将永久保存，不管是否出现故障
    CAP理论
        Consistency（一致性）：
            用户访问分布式系统中的任意节点，得到的数据必须一致
        Availability （可用性）：
            用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝
        Partition tolerance（分区容错）：
            因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。
            在集群出现分区时，整个系统也要持续对外提供服务
    Base理论
        Basically Available（基本可用）：
            分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。
        Soft State（软状态）：
            在一定时间内，允许出现中间状态，比如临时的不一致状态。
        Eventually Consistent（最终一致性）：
            虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。
    Base和CAP
        AP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。
        CP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态