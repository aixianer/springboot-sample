一、Token
    1、什么是token
        Token，也称为“令牌”，是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
    2、为什么使用token
        传统方式即cookie+session的方式，引发的问题比如用户增多导致内存开销较大、CORS(跨域资源共享)以及CSRF(跨站请求伪造)等。
        引入Token验证机制后，请求会发送token而不再是发送cookie能有效够防止CSRF，即使在客户端使用cookie存储token，但cookie也只有存储功能，而不再具备验证功能，因此安全性得到了极大的提高。
        只要token设计的足够复杂，除非用户泄露，否则几乎没有被破解的可能，加上token是有时效的，在有限的时间加上有限的算力，更是无懈可击。
        Token可以有效减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。
    3、token的认证流程
        客户端使用用户名跟密码请求登录
        服务端收到请求，去验证用户名与密码
        验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
        客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里
        客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
        服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据
    4、token的使用
        每次请求都会将Token放在请求头中一起发送到服务器端，服务器端通过拦截器进行拦截校验，如果不存在Token、Token错误或者Token过期，则拒绝请求，有效则返回相应的返回结果。
    5、Token生成示例
        使用使用用户唯一ID + 系统时间 + 随机数 + 过期时间得到用户信息数据字符串
        对字符串进行RSA非对称加密/AES对称加密得到一个加密字符串
        将加密字符串A再次进行签名等到一个签名数据
        将签名数据和加密字符串进行拼接，最后使用base64进行编码，得到令牌
    6、token和session的比较
        支持跨域访问：cookie是无法跨域的，而token由于没有用到cookie(前提是将token放到请求头中)，所以跨域后不会存在信息丢失问题
        无状态：token机制在服务端不需要存储session信息，因为token自身包含了所有登录用户的信息，所以可以减轻服务端压力
        更适用CDN：可以通过内容分发网络请求服务端的所有资料
        更适用于移动端：当客户端是非浏览器平台时，cookie是不支持的，采用token认证方式会简单很多
        无需考虑CSRF：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御
二、JWT
    JSON Web Token（JWT）是一个开发标准（RFC 7519），它定义了一种紧凑独立的基于 JSON 对象在各方之间安全地传输信息的方式。
    1、JWT的组成部分
        base64 URL(头部) + "." +base64 URL(负载) + "." + base64 URL(签名)
        （1）Header(头部)
            {
              "alg": "HS256",
              "typ": "JWT"
            }
            alg是签名用的算法，默认为HMAC SHA256（写为HS256），JWT默认也是推荐的算法
            typ属性表示令牌的类型，JWT令牌统一写为JWT
        （2）payload(负载)
            JWT的主体内容部分，也是JSON，包含需要传递的数据
            JWT指定七个默认字段供选择
            iss：发行人；exp：到期时间；sub：主题；aud：用户；nbf：在此之前不可用；iat：发布时间；jti：JWT ID用于标识该JWT

            除默认字段外，我们还可以自定义字段，一般会把包含用户信息的数据放到payload中，如下
            {
              "sub": "1234567890",
              "userID": "123456",
              "admin": true
            }
            JWT里不要存放敏感信息，因为base64 URL编码是可以解码的
        （3）Signature（签名）
            需要指定一个密钥(secretKey)，该密钥只存在服务器中，不能向用户公开公开，使用header中指定的签名算法默认情况下为HMAC SHA256）根据以下公式生成签名。
            Signature = HS256(Base64(头部) + "." + Base64(负载) ,  secretKey)

    2、JWT校验
        header 和 payload可以直接利用base64 URL解码出原文。
        从header中获取哈希签名的算法，从payload中获取有效数据。
        signature使用了不可逆的加密算法，无法解码出原文，它的作用是校验token有没有被篡改。
        服务端用header、payload、secretKey通过header中的签名算法进行再次加密，比对加密后的数据和客户端发送过来token中的的是否一致。
        无论改了头部、负载、和签名中的哪个部分，token校验都不会通过

    3、JWT的优点
        简洁: 可以通过URL、POST参数或者在HTTP header发送，因为数据量小，传输速度也很快
        自包含：负载中可以包含用户所需要的信息，避免了多次查询数据库
        Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持
        不需要在服务端保存会话信息，特别适用于分布式微服务
三、常用的token续期方案
    单token续期方案
        1.用户登录，服务端返回生成的Jwt,携带必要的信息。
        2.用户再次访问时均需要在Authorization Header中携带Jwt。
        3.服务端有配置好的token失效时间或者次数，还有重新登录期限。每次登录会记录当前登录时间。
        4.用户携带token访问时，服务端根据token失效时间和重新登录期限判断返回对应代码
        5.当token有效时，服务端返回对应资源。
        6.当token失效时，前端拿到错误代码后重新请求refresh token接口进行token刷新，该接口会返回新的有效token给前端。
        7.前端下次请求会携带刷新后的新token访问。
        8.当某次访问时，服务端判断token使用时长超过了定义好的登录期限，则返回重新登录错误代码给前端，前端拿到代码后跳转至登录页面。
    双token的续期方案
        1.用户登录返回access_token、refresh_token。
        2.用户请求资源时携带access_token。
        3.当access_token有效时，返回对应的资源。
        4.当服务端校验access_token失效，则返回对应错误代码。
        5.前端拿到access_token失效对应的错误代码，发起刷新token请求，本次请求携带之前缓存的refresh_token。
        6.服务端拿到refresh_token，判断是否有效，失效则返回重新登录错误代码。
        7.前端拿到重新登录错误代码则跳转登录页面。
四、Auth2.0和JWT应用场景
    JWT是一种认证协议，提供了一种用于发布接入令牌（Access Token),并对发布的签名接入令牌进行验证的方法。
    OAuth2.0是一种授权框架，提供了一套详细的授权机制（指导）。用户或应用可以通过公开的或私有的设置，授权第三方应用访问特定资源。

    OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)
    JWT是用在前后端分离, 需要简单的对后台API进行保护时使用.(前后端分离无session, 频繁传用户密码不安全)

五、JWT的缺点
    安全性没法保证，所以 jwt 里不能存储敏感数据。因为 jwt 的 payload 并没有加密，只是用 Base64 编码而已。
    无法中途废弃。因为一旦签发了一个 jwt，在到期之前始终都是有效的，如果用户信息发生更新了，只能等旧的 jwt 过期后重新签发新的 jwt。
    续签问题。当签发的 jwt 保存在客户端，客户端一直在操作页面，按道理应该一直为客户端续长有效时间，否则当 jwt有效期到了就会导致用户需要重新登录。那么怎么为 jwt 续签呢？最简单粗暴就是每次签发新的 jwt，但是由于过于暴力，会影响性能。如果要优雅一点，又要引入 Redis 解决