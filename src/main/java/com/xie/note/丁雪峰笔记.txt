5、如何配置数据源
    （1）单个数据源
        springboot:
            //pom
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-jdbc</artifactId>
            </dependency>
            <dependency>
                <groupId>com.h2database</groupId>
                <artifactId>h2</artifactId>
                <scope>runtime</scope>
            </dependency>
            //java
            @Autowired
            private DataSource dataSource;
            //properties
            spring.datasource.url=jdbc:h2:mem:testdb
            spring.datasource.username=sa
            spring.datasource.password=
            spring.datasource.hikari.maximumPoolSize=5
            spring.datasource.hikari.minimumIdle=5
            spring.datasource.hikari.idleTimeout=600000
            spring.datasource.hikari.connectionTimeout=30000
            spring.datasource.hikari.maxLifetime=1800000


        spring中配置数据源：
        方式1：
            import javax.sql.DataSource;
            @Autowired
            private DataSource dataSource;
            @Bean(destroyMethod = "close")
            public DataSource dataSource() throws Exception {
                Properties properties = new Properties();
                properties.setProperty("driverClassName", "org.h2.Driver");
                properties.setProperty("url", "jdbc:h2:mem:testdb");
                properties.setProperty("username", "sa");
                return BasicDataSourceFactory.createDataSource(properties);
            }
（2）多个数据源
    1、屏蔽自带的datasource
        @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class,
                DataSourceTransactionManagerAutoConfiguration.class,
                JdbcTemplateAutoConfiguration.class})
    2、自定义datasource和trxbean
         @Bean
            public DataSource fooDataSource() {
                DataSourceProperties dataSourceProperties = fooDataSourceProperties();
                log.info("foo datasource: {}", dataSourceProperties.getUrl());
                return dataSourceProperties.initializeDataSourceBuilder().build();
            }

            @Bean
            @Resource
            public PlatformTransactionManager fooTxManager(DataSource fooDataSource) {
                return new DataSourceTransactionManager(fooDataSource);
            }

            @Bean
            @ConfigurationProperties("bar.datasource")
            public DataSourceProperties barDataSourceProperties() {
                return new DataSourceProperties();
            }

            @Bean
            public DataSource barDataSource() {
                DataSourceProperties dataSourceProperties = barDataSourceProperties();
                log.info("bar datasource: {}", dataSourceProperties.getUrl());
                return dataSourceProperties.initializeDataSourceBuilder().build();
            }

            @Bean
            @Resource
            public PlatformTransactionManager barTxManager(DataSource barDataSource) {
                return new DataSourceTransactionManager(barDataSource);
            }
    3、配置文件
        foo.datasource.url=jdbc:h2:mem:foo
        foo.datasource.username=sa
        foo.datasource.password=
        bar.datasource.url=jdbc:h2:mem:bar
        bar.datasource.username=sa
        bar.datasource.password=
7、HikariCP
springboot2
    默认使用了HikariCP
    配置spring.datasource.hikari.*
springboot1
    在pom文件中，默认使用了tomcat，如果改动需要移除tomcat依赖
    将spring.datasource.type=com.zaxxer.hikari.HikariDataSource

8、Durid
    优点：
        详情的监控
        ExceptionSorter，针对主流数据库返回码都支持
        SQL防注入
        内置加密支持
        众多扩展点，方便进行定制
    配置方式：
        （1）Spring的bean当中配置DuridDataSource
        （2）springboot使用durid-spring-boot-starter;
            配置文件中配置spring.datasource.durid.*
    如何选择连接池：
        可靠性，性能，功能，监控；可运维性，可扩展性，其他；
9、spring jdbc访问数据库
    主要包含：
        core,JdbcTemplate等相关核心接口和类
        datasiource，数据源相关的辅助类
        object，将基本的jdbc操纵封装成对象
        support,错误码等其他辅助工具
    常用bean注解：
        @Componment:通用的注解，定义通用的bean
        @Respository:dao，数据库相关的操作
        @Service：一些内部的服务
        @Controller：spring mvc
            @RestController
    JdbcTemplate
        query
        queryForObject
        queryForList
        update:更新删除
        execute
    代码
        JdbcTemplate
        NamedParameterJdbcTemplate

10、Spring事务抽象
    事务抽象的核心接口
        PlatformTransacionManager
            DataSourceTransactionManager
            d
            JtdTransactionManager
        TransactionDefinition
            Propagation
            Isolation
            Timeout
            Read-only satatus

    事务传播特性，7种
        requried:当前有事务就用当前的，没有就用新的
        supports:事务可有可无，不是必须的
        mandatory:当前一定要有事务，没有就抛出异常
        requires_new：无论是否有，都起一个新事务
        not_supported:不支持事务，按照非事务方式运行
        never:不支持事务，如果有就抛出异常
        nested:里面回滚，不影响大事务
    事务隔离特性（取决于数据库）：
        串行
        可重复读
        不可重复度
        脏读（读未提交）
11、Spring事务抽象下
    编程式事务
        TransactionTemplate
        PlatFromTransactionManager
            传入TransacrtionDefinition
    声明式事务
        本质上式通过AOP增强了类的功能
        Spring的AOP本质上就是为类做了一个代理
            看似在调用给自己的类，实际上式用的增强后的代理类
            访问增强后的代理类的方法，而废直接访问自身的方法
        xml方式
            @EnableTransactionmanagerManagement

        @Transactional
            transactionManager
            propagation
12、Spring的JDBC异常抽象
    Spring会将数据操作的异常转为DataAccessException
    通过SQLErrorCodeSQLExcetpionTranslator
    ErrorCode定义
        org.springframework.jdbc.sql-error-codex.xml
        classpath下可以定义sql-error-codex.xml覆盖jdbc包下的

20、通过MyBatis操作数据库
    认识MyBatis
        一款优秀的持久层框架
        支持定制的SQL、存储过程和高级映射
    在Spring中使用MyBatis
        MyBatis Spring Adapter
        MyBatis Spring-Boot-Starter
    定制sql支持性较好，如果dba要求严格，可以考虑使用MyBatis
    简单配置
        //设置映射文件
        • mybatis.mapper-locations = classpath*:mapper/**/*.xml
        • mybatis.type-aliases-package = 类型别名的包名
        //类型转换使用的辅助类
        • mybatis.type-handlers-package = TypeHandler扫描包名
        //下划线转驼峰规则
        • mybatis.configuration.map-underscore-to-camel-case = true
    Mapper的定义和扫描
        @MapperScan配置扫描配置
        @Mapper定义接口
        映射的定义--XML与注解
        @Mapper,@Insert,@Options,@Select
    BaseTypeHandler
        继承此接口可实现类型转换
        mybatis.type-handlers-package=
    一些代码：
        @Mapper
        public interface CoffeeMapper {
            @Insert("insert into t_coffee (name, price, create_time, update_time)"
                    + "values (#{name}, #{price}, now(), now())")
            @Options(useGeneratedKeys = true)
            int save(Coffee coffee);

            @Select("select * from t_coffee where id = #{id}")
            @Results({
                    @Result(id = true, column = "id", property = "id"),
                    @Result(column = "create_time", property = "createTime"),
                    // map-underscore-to-camel-case = true 可以实现一样的效果
                    // @Result(column = "update_time", property = "updateTime"),
            })
            Coffee findById(@Param("id") Long id);
        }
    分页工具：

26、在Spring中访问redis

39、编写第一个Spring Mvc
    DispatchServlet:所有请求的一个入口
        Controller
        xxxResolver
            ViewResolver
            HandlerExceptionResolver
            MultipartResolver
        HandlerMappingL映射处理
    常用注解：
        @Controller：定义控制器
            @RestController：结合了controller和responseBody
        @RequestMapping：我这个controller要处理哪一些请求
            @GetMapping,@PostMapping
            @DeleteMapping,@PutMapping
        @RequestBody：请求的报文体
        @ResponseBody：响应的报文体
        @ResponseStatus：指定请求返回http响应码

40、Spring应用上下文
    依赖注入也是通过SpringContext来实现的，配置文件或者配置获取组件间的以来信息，applicationContext负责注入
    上下文中常用的接口和实现
    BeanFactory
        DefaultListableBeanFactory
    ApplicationContext
        ClassPathXmlApplicationContext：通过classpath下的xml配置文件
        FileSystemXmlApplicationContext：在文件系统中寻找xml文件
        AnnotationConfigApplicationContext：从注解中获取
    WebApplicationContext

    一般情况下我们不会直接使用BeanFactory，我们一般都是通过使用ApplicationContext的一些实现类；
    里面会对BeanPostProcessor和BeanFactoryPostProcessor的一些自动的注册的功能（springboot里会详细说明）

    Web上下文的层次关系：
    DispatcherServlet
    Servlet WebApplicationContext：存放spring mvc相关的bean
        Controllers
        ViewResolver
        HandlerMapping
    Root WebAppitlicationContext
        Services
        Repositories
    Servlet会继承Root，在servlet当中找不到某个bean时候它会到root中做寻找；
    如果我定义了AOP拦截在servlet，但是拦截的目标出现在root里，增强是否会生效
    xml:
        root:ContextLoaderListener
            service,dao相关
        servlet:DispatchServlet
    代码方式（Configuration）：
        RootConfig.class
        App1Config.class
    示例：context-hierarchy-demo
        @EnableAspectJAutoProxy？
        @ComponentScan
    如果是希望对底层的那些bean做增强，增强AOP的这些配置配置在底层上下文当中；
    如果是希望对上层，那么就配置在上层；
    如果是通用的，两个上下文当中都开启AOP的增强，但是把Aspect定义在Root的Application
    ？？？？

41、理解请求的处理机制
    1、个请求的大致处理流程
    （1）绑定一些attribute
        WebApplicationContext/LocaleResolver/ThemeResolver
    （2）处理Multipart
        如果是，将请求转为MultipartHttpServlet
    （3）Handler处理
        如果找到Handler，执行Controller及前后置处理器逻辑
    （4）处理返回的Model，呈现视图

42、如何定义处理方法上
    1、定义映射关系
        @Controller
            标志该层为表现层或者控制层；具有component的基础含义，被spring管理，当成bean注入到spring容器中；可以让该类中的方法返回String，该String默认就是view-name
            @RestController: @Controller，@ResponseBody
        @RequestMapping
            path(value): 指定请求的实际访问地址，默认@RequestMapping("url")的值url即为value的值
            method:请求的method的类型，主要有：GET、POST、DELETE、PUT
            params：指定request中必须包含某些参数值，包含才让该方法处理请求
            headers：指定request中必须包含某些指定的header值，包含才能让该方法处理请求。
            consumes：指定处理请求的提交内容类型（Content-Type），例如：application/json, text/html;
            produces：指定返回的内容类型，当且仅当request请求头中的(Accept)类型中包含该指定类型才返回；
        一些快捷方式
            @GetMapping：@RequestMapping(method = RequestMethod.GET)
            @PostMapping：@RequestMapping(method = RequestMethod.POST)
            @PutMapping：@RequestMapping(method = RequestMethod.PUT)
            @DeleteMapping：@RequestMapping(method = RequestMethod.DELETE)
            @PatchMapping：@RequestMapping(method = RequestMethod.PATCH)
    2、请求相关
        @RequestParam：
            常用来处理简单类型的绑定，通过request.getParameter() 获取的String可直接转换为简单类型的情况
            用来处理Content-Type: 为application/x-www-form-urlencoded编码的内容，提交方式GET、POST；
            defaultValue 表示设置默认值，required通过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。
        @RequestBody：
            该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；
            它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。
            (使用FormHttpMessageConverter可以处理application/x-www-form-urlencoded)
        @RequestHeader
            可以把Request请求header部分的值绑定到方法的参数上
            public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive)
        @CookieValue
            绑定 cookie 的值到 Controller 方法参数
            public String testCookieValue(@CookieValue ( "hello" ) String cookieValue, @CookieValue String hello)
        @PathVariable：
            用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数

        RequestEntity
            表示完整的请求报文（用的少，几乎不用）
            其中getHeaders()获取请求报文的请求头信息
            其中getBody()获取请求报文的请求体信息
    3、返回相关
        @ResponseBody：
            将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。
        @ResponseStatus
            指定控制器方法抛出异常时的 HTTP 状态码
            （1）和@RequestMapping配合
                如果不使用，默认返回200，表示浏览器中共南昌渲染试图
                如果使用，不设定200，浏览器仍可正常渲染试图，但是可回调error函数
            （2）和@ExceptionHandler配合
                和1区别不大
            （3）加在自定义异常上面
                如果不加，在代码中直接抛出该自定义异常，会以500的HTTP状态码响应到浏览器
                如果加，在代码中直接抛出该自定义异常，会以指定的HTTP状态码和指定的reason响应到浏览器
        ResponseEntity
            ResponseEntity 设置响应到浏览器的响应报文
            ResponseEntity类型用在控制器方法的返回值，返回的ResponseEntity就是响应到浏览器的响应报文。

43、如何定义处理方法下（没看懂，需要刷视频；例子：more-complex-controller-demo）
    类型转换WebMvcConverter（MoneyFormatter.java）
        Spring Boot 在 WebMvcAutoConfiguration 中实现了⼀个
        添加⾃定义的 Converter
        添加⾃定义的 Formatter
    定义校验
        通过 Validator 对绑定结果进⾏校验
            Hibernate Validator
        @Valid 注解
        BindingResult
            public Coffee addCoffee(@Valid NewCoffeeRequest newCoffee,BindingResult result)
    Multipart 上传
        配置 MultipartResolver
            Spring Boot ⾃动配置 MultipartAutoConfiguration
        ⽀持类型 multipart/form-data
        MultipartFile 类型

44、Spring MVC视图解析机制上
    1、ViewResolver 与 View 接⼝
        AbstractCachingViewResolver：缓存，抽象的基类
        UrlBasedViewResolver
        FreeMarkerViewResolver：freeMarker
        ContentNegotiatingViewResolver:
            根据我可以接受的返回类型来选择一个合适的响应，xml、json的
            把相应的这些请求转给合适的ViewResolver继续做一个处理
        InternalResourceViewResolver
            最后的内置的解析器，它是用来处理JSP还有JSTL的
        这些ViewResolver他们每一个都可以去做一个解析，返回一个View对象，再用View对象做一个呈现
    2、如何做试图解析
        initStrategies()
            initViewResolvers()初始化了对应ViewResolver
            它会加载spring上下文中的所有的ViewResolvers
        doDispatch()
            processDispatchResult()
                视图名到具体视图的一个解析，解析出之后，做一个视图的呈现
                如果没有返回视图的话，尝试RequestToViewNameTranslator
                resolveViewName()解析View对象
                如果有异常，会做一个异常视图的处理

        初始化DispatcherServlet的时候，会初始化ViewResolver

45、Spring MVC视图解析机制下
    使⽤ @ResponseBody 的情况


        后台直接返回pojo对象，前端直接接收为json对象或者字符串，使⽤注解@ResponseBody，此注解不走视图解析器;
        当方法上面没有写ResponseBody,底层会将方法的返回值封装为ModelAndView对象。


        • 在 HandlerAdapter.handle() 的中完成了 Response 输出
            • RequestMappingHandlerAdapter.invokeHandlerMethod()
            • HandlerMethodReturnValueHandlerComposite.handleReturnValue()
            • RequestResponseBodyMethodProcessor.handleReturnValue()
    重定向的视图
        redirect:相当于做了一个http302的跳转，可以认为是客户端发起的重定向的跳转；可能会丢失上一个请i去的request信息
        forward:服务端发起的，浏览器上不会发现变化

46、Spring MVC中的常用视图（上）di's
    messageconverter

47、Spring MVC中的常用视图（下）

49、Spring MVC中的异常处理机制
    核心接口：HandlerExceptionResolver
    实现类：
        SimpleMappingExceptionResolver
        DefaultHandlerExceptionResolver
        ResponseStatusExceptionResolver
        ExceptionHandlerExceptionResolver

    异常处理方法：@ExceptionHandler
    添加位置
        @Controller/@RestController
            优先级高
        @ControllerAdvice/@RestControllerAdvice
            优先级低

    代码：
        @ControllerAdvice
        public class GlobalControllerAdvice {
            @ExceptionHandler(ValidationException.class)
            @ResponseStatus(HttpStatus.BAD_REQUEST)
            public Map<String, String> validationExceptionHandler(ValidationException exception) {
                Map<String, String> map = new HashMap<>();
                map.put("message", exception.getMessage());
                return map;
            }
        }

50、Spring当中的切入点
    （1）核心接口：
        HandlerInterceptor
            boolean preHandle();
                预处理，如权限验证
            void postHandle();
                视图呈现前
            void afterCompletion();
                视图呈现后
    （2）针对@ResponseBody和ResponseEntity
        ResponseBodyAdvice
    （3）针对异步请求的接口
        AsyncHandlerInterceptor
            void afterConcurrentHandlingStarted();
    （4）拦截器的配置方式
        常规方法：
            WebMvcConfigurer.addInterceptors();
        Spring boot中的配置：
            创建一个@Configuration的WebMvcConfigurer配置类
            不能带有@EnableWebMvc（想彻底控制MVC除外）