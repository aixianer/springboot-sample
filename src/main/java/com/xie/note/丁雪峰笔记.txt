5、如何配置数据源
    （1）单个数据源
        springboot:
            //pom
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-jdbc</artifactId>
            </dependency>
            <dependency>
                <groupId>com.h2database</groupId>
                <artifactId>h2</artifactId>
                <scope>runtime</scope>
            </dependency>
            //java
            @Autowired
            private DataSource dataSource;
            //properties
            spring.datasource.url=jdbc:h2:mem:testdb
            spring.datasource.username=sa
            spring.datasource.password=
            spring.datasource.hikari.maximumPoolSize=5
            spring.datasource.hikari.minimumIdle=5
            spring.datasource.hikari.idleTimeout=600000
            spring.datasource.hikari.connectionTimeout=30000
            spring.datasource.hikari.maxLifetime=1800000


        spring中配置数据源：
        方式1：
            import javax.sql.DataSource;
            @Autowired
            private DataSource dataSource;
            @Bean(destroyMethod = "close")
            public DataSource dataSource() throws Exception {
                Properties properties = new Properties();
                properties.setProperty("driverClassName", "org.h2.Driver");
                properties.setProperty("url", "jdbc:h2:mem:testdb");
                properties.setProperty("username", "sa");
                return BasicDataSourceFactory.createDataSource(properties);
            }
（2）多个数据源
    1、屏蔽自带的datasource
        @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class,
                DataSourceTransactionManagerAutoConfiguration.class,
                JdbcTemplateAutoConfiguration.class})
    2、自定义datasource和trxbean
         @Bean
            public DataSource fooDataSource() {
                DataSourceProperties dataSourceProperties = fooDataSourceProperties();
                log.info("foo datasource: {}", dataSourceProperties.getUrl());
                return dataSourceProperties.initializeDataSourceBuilder().build();
            }

            @Bean
            @Resource
            public PlatformTransactionManager fooTxManager(DataSource fooDataSource) {
                return new DataSourceTransactionManager(fooDataSource);
            }

            @Bean
            @ConfigurationProperties("bar.datasource")
            public DataSourceProperties barDataSourceProperties() {
                return new DataSourceProperties();
            }

            @Bean
            public DataSource barDataSource() {
                DataSourceProperties dataSourceProperties = barDataSourceProperties();
                log.info("bar datasource: {}", dataSourceProperties.getUrl());
                return dataSourceProperties.initializeDataSourceBuilder().build();
            }

            @Bean
            @Resource
            public PlatformTransactionManager barTxManager(DataSource barDataSource) {
                return new DataSourceTransactionManager(barDataSource);
            }
    3、配置文件
        foo.datasource.url=jdbc:h2:mem:foo
        foo.datasource.username=sa
        foo.datasource.password=
        bar.datasource.url=jdbc:h2:mem:bar
        bar.datasource.username=sa
        bar.datasource.password=
7、HikariCP
springboot2
    默认使用了HikariCP
    配置spring.datasource.hikari.*
springboot1
    在pom文件中，默认使用了tomcat，如果改动需要移除tomcat依赖
    将spring.datasource.type=com.zaxxer.hikari.HikariDataSource

8、Durid
    优点：
        详情的监控
        ExceptionSorter，针对主流数据库返回码都支持
        SQL防注入
        内置加密支持
        众多扩展点，方便进行定制
    配置方式：
        （1）Spring的bean当中配置DuridDataSource
        （2）springboot使用durid-spring-boot-starter;
            配置文件中配置spring.datasource.durid.*
    如何选择连接池：
        可靠性，性能，功能，监控；可运维性，可扩展性，其他；
9、spring jdbc访问数据库
    主要包含：
        core,JdbcTemplate等相关核心接口和类
        datasiource，数据源相关的辅助类
        object，将基本的jdbc操纵封装成对象
        support,错误码等其他辅助工具
    常用bean注解：
        @Componment:通用的注解，定义通用的bean
        @Respository:dao，数据库相关的操作
        @Service：一些内部的服务
        @Controller：spring mvc
            @RestController
    JdbcTemplate
        query
        queryForObject
        queryForList
        update:更新删除
        execute
    代码
        JdbcTemplate
        NamedParameterJdbcTemplate

10、Spring事务抽象
    事务抽象的核心接口
        PlatformTransacionManager
            DataSourceTransactionManager
            d
            JtdTransactionManager
        TransactionDefinition
            Propagation
            Isolation
            Timeout
            Read-only satatus

    事务传播特性，7种
        requried:当前有事务就用当前的，没有就用新的
        supports:事务可有可无，不是必须的
        mandatory:当前一定要有事务，没有就抛出异常
        requires_new：无论是否有，都起一个新事务
        not_supported:不支持事务，按照非事务方式运行
        never:不支持事务，如果有就抛出异常
        nested:里面回滚，不影响大事务
    事务隔离特性（取决于数据库）：
        串行
        可重复读
        不可重复度
        脏读（读未提交）
11、Spring事务抽象下
    编程式事务
        TransactionTemplate
        PlatFromTransactionManager
            传入TransacrtionDefinition
    声明式事务
        本质上式通过AOP增强了类的功能
        Spring的AOP本质上就是为类做了一个代理
            看似在调用给自己的类，实际上式用的增强后的代理类
            访问增强后的代理类的方法，而废直接访问自身的方法
        xml方式
            @EnableTransactionmanagerManagement

        @Transactional
            transactionManager
            propagation
12、Spring的JDBC异常抽象
    Spring会将数据操作的异常转为DataAccessException
    通过SQLErrorCodeSQLExcetpionTranslator
    ErrorCode定义
        org.springframework.jdbc.sql-error-codex.xml
        classpath下可以定义sql-error-codex.xml覆盖jdbc包下的

20、通过MyBatis操作数据库
    认识MyBatis
        一款优秀的持久层框架
        支持定制的SQL、存储过程和高级映射
    在Spring中使用MyBatis
        MyBatis Spring Adapter
        MyBatis Spring-Boot-Starter
    定制sql支持性较好，如果dba要求严格，可以考虑使用MyBatis
    简单配置
        //设置映射文件
        • mybatis.mapper-locations = classpath*:mapper/**/*.xml
        • mybatis.type-aliases-package = 类型别名的包名
        //类型转换使用的辅助类
        • mybatis.type-handlers-package = TypeHandler扫描包名
        //下划线转驼峰规则
        • mybatis.configuration.map-underscore-to-camel-case = true
    Mapper的定义和扫描
        @MapperScan配置扫描配置
        @Mapper定义接口
        映射的定义--XML与注解
        @Mapper,@Insert,@Options,@Select
    BaseTypeHandler
        继承此接口可实现类型转换
        mybatis.type-handlers-package=
    一些代码：
        @Mapper
        public interface CoffeeMapper {
            @Insert("insert into t_coffee (name, price, create_time, update_time)"
                    + "values (#{name}, #{price}, now(), now())")
            @Options(useGeneratedKeys = true)
            int save(Coffee coffee);

            @Select("select * from t_coffee where id = #{id}")
            @Results({
                    @Result(id = true, column = "id", property = "id"),
                    @Result(column = "create_time", property = "createTime"),
                    // map-underscore-to-camel-case = true 可以实现一样的效果
                    // @Result(column = "update_time", property = "updateTime"),
            })
            Coffee findById(@Param("id") Long id);
        }
    分页工具：

26、在Spring中访问redis

39、编写第一个Spring Mvc
    DispatchServlet:所有请求的一个入口
        Controller
        xxxResolver
            ViewResolver
            HandlerExceptionResolver
            MultipartResolver
        HandlerMappingL映射处理
    常用注解：
        @Controller：定义控制器
            @RestController：结合了controller和responseBody
        @RequestMapping：我这个controller要处理哪一些请求
            @GetMapping,@PostMapping
            @DeleteMapping,@PutMapping
        @RequestBody：请求的报文体
        @ResponseBody：响应的报文体
        @ResponseStatus：指定请求返回http响应码

40、Spring应用上下文
    依赖注入也是通过SpringContext来实现的，配置文件或者配置获取组件间的以来信息，applicationContext负责注入
    上下文中常用的接口和实现
    BeanFactory
        DefaultListableBeanFactory
    ApplicationContext
        ClassPathXmlApplicationContext：通过classpath下的xml配置文件
        FileSystemXmlApplicationContext：在文件系统中寻找xml文件
        AnnotationConfigApplicationContext：从注解中获取
    WebApplicationContext

    一般情况下我们不会直接使用BeanFactory，我们一般都是通过使用ApplicationContext的一些实现类；
    里面会对BeanPostProcessor和BeanFactoryPostProcessor的一些自动的注册的功能（springboot里会详细说明）

    Web上下文的层次关系：
    DispatcherServlet
    Servlet WebApplicationContext：存放spring mvc相关的bean
        Controllers
        ViewResolver
        HandlerMapping
    Root WebAppitlicationContext
        Services
        Repositories
    Servlet会继承Root，在servlet当中找不到某个bean时候它会到root中做寻找；
    如果我定义了AOP拦截在servlet，但是拦截的目标出现在root里，增强是否会生效
    xml:
        root:ContextLoaderListener
            service,dao相关
        servlet:DispatchServlet
    代码方式（Configuration）：
        RootConfig.class
        App1Config.class
    示例：context-hierarchy-demo
        @EnableAspectJAutoProxy？
        @ComponentScan
    如果是希望对底层的那些bean做增强，增强AOP的这些配置配置在底层上下文当中；
    如果是希望对上层，那么就配置在上层；
    如果是通用的，两个上下文当中都开启AOP的增强，但是把Aspect定义在Root的Application
    ？？？？

41、理解请求的处理机制
    1、个请求的大致处理流程
    （1）绑定一些attribute
        WebApplicationContext/LocaleResolver/ThemeResolver
    （2）处理Multipart
        如果是，将请求转为MultipartHttpServlet
    （3）Handler处理
        如果找到Handler，执行Controller及前后置处理器逻辑
    （4）处理返回的Model，呈现视图

42、如何定义处理方法上
    1、定义映射关系
        @Controller
            标志该层为表现层或者控制层；具有component的基础含义，被spring管理，当成bean注入到spring容器中；可以让该类中的方法返回String，该String默认就是view-name
            @RestController: @Controller，@ResponseBody
        @RequestMapping
            path(value): 指定请求的实际访问地址，默认@RequestMapping("url")的值url即为value的值
            method:请求的method的类型，主要有：GET、POST、DELETE、PUT
            params：指定request中必须包含某些参数值，包含才让该方法处理请求
            headers：指定request中必须包含某些指定的header值，包含才能让该方法处理请求。
            consumes：指定处理请求的提交内容类型（Content-Type），例如：application/json, text/html;
            produces：指定返回的内容类型，当且仅当request请求头中的(Accept)类型中包含该指定类型才返回；
        一些快捷方式
            @GetMapping：@RequestMapping(method = RequestMethod.GET)
            @PostMapping：@RequestMapping(method = RequestMethod.POST)
            @PutMapping：@RequestMapping(method = RequestMethod.PUT)
            @DeleteMapping：@RequestMapping(method = RequestMethod.DELETE)
            @PatchMapping：@RequestMapping(method = RequestMethod.PATCH)
    2、请求相关
        @RequestParam：
            常用来处理简单类型的绑定，通过request.getParameter() 获取的String可直接转换为简单类型的情况
            用来处理Content-Type: 为application/x-www-form-urlencoded编码的内容，提交方式GET、POST；
            defaultValue 表示设置默认值，required通过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。
        @RequestBody：
            该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；
            它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。
            (使用FormHttpMessageConverter可以处理application/x-www-form-urlencoded)
        @RequestHeader
            可以把Request请求header部分的值绑定到方法的参数上
            public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive)
        @CookieValue
            绑定 cookie 的值到 Controller 方法参数
            public String testCookieValue(@CookieValue ( "hello" ) String cookieValue, @CookieValue String hello)
        @PathVariable：
            用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数

        RequestEntity
            表示完整的请求报文（用的少，几乎不用）
            其中getHeaders()获取请求报文的请求头信息
            其中getBody()获取请求报文的请求体信息
    3、返回相关
        @ResponseBody：
            将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。
        @ResponseStatus
            指定控制器方法抛出异常时的 HTTP 状态码
            （1）和@RequestMapping配合
                如果不使用，默认返回200，表示浏览器中共南昌渲染试图
                如果使用，不设定200，浏览器仍可正常渲染试图，但是可回调error函数
            （2）和@ExceptionHandler配合
                和1区别不大
            （3）加在自定义异常上面
                如果不加，在代码中直接抛出该自定义异常，会以500的HTTP状态码响应到浏览器
                如果加，在代码中直接抛出该自定义异常，会以指定的HTTP状态码和指定的reason响应到浏览器
        ResponseEntity
            ResponseEntity 设置响应到浏览器的响应报文
            ResponseEntity类型用在控制器方法的返回值，返回的ResponseEntity就是响应到浏览器的响应报文。
43、如何定义处理方法下
    类型转换
        WebMvcConverter
    定义校验
        通过 Validator 对绑定结果进⾏校验
            Hibernate Validator
        @Valid 注解
        BindingResult
    Multipart 上传
        配置 MultipartResolver
            Spring Boot ⾃动配置 MultipartAutoConfiguration
        ⽀持类型 multipart/form-data
        MultipartFile 类型


