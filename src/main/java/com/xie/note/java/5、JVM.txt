反射
    定义
        JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
        对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
            通过该类的“字节码文件对象”来获取
        反射就是把java类中的各种成分映射成一个个的Java对象
        加载的过程：Class对象的由来是将class文件读入内存，并为之创建唯一的一个Class对象。
    Class类
        Class 类的实例表示正在运行的 Java 应用程序中的类和接口。
            也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）
        Class 没有公共构造方法。
            Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。
        获取Class的三种方式
            stu.getClass():
                对象都有了，还要反射干嘛
            Student.class
                需要import类
            Class.forName("com.xie.java.jvm.Student")
    反射的使用
        构造方法
            全部：clazz.getDeclaredConstructors()
            公有：clazz.getConstructors()
            公有无参数：clazz.getConstructor(null)
            私有int参：clazz.getDeclaredConstructor(int.class)
            创建对象
                con.newInstance(18)
        成员变量
            全部：getDeclaredFields
            公有：getFields
            根据参数名：stuClass.getField("name")
            设置值
                Field f = stuClass.getDeclaredFields("name");
                f.setAccessible(true);//私有字段可以通过这个设置进行“暴力反射”
                Object obj = stuClass.getConstructor().newInstance();
                f.set(obj, "刘德华");
        方法
            全部：getDeclaredMethods
            全部公有（含父类）：getMethods
            根据参数列表获取：Method m = stuClass.getMethod("show1", String.class);
            调用：
                Method m = stuClass.getDeclaredMethods("show1", String.class);
                m.setAccessible(true);//解除私有限定
                //实例化一个Student对象
                Object obj = stuClass.getConstructor().newInstance();
                m.invoke(obj, "刘德华");
                如果是静态方法
                m.invoke(null, "刘德华");
    应用：
        （1）运行配置文件内容
        （2）越过泛型检查
            ArrayList<String> list = new ArrayList<>();
            list.add("aaa");
            Class listClass = list.getClass();
            Method m = listClass.getMethod("add", Object.class);
            m.invoke(list, 100);
            for(Object obj : list){
                System.out.println(obj +":"+ obj.getClass());
            }

类的生命周期
    JVM虚拟机把.class文件中类信息加载进内存并进行解析生成对应的class对象,Class对象被JVM使用,最后随着JVM要关闭而卸载的整个过程
    相关的存储：
        方法区：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。
        常量池：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。
    加载
        找到一个需要的类（字节码的class文件），并把类的信息通过类加载器载入内存中（JVM的方法区），
            然后在堆中实例化一个java.lang.Class对象来作为这个类的信息的入口
        字节码的来源
            本地路径下编译生成的class文件
            jar包中的class文件，
            远程网络
            动态代理实时编译
        类加载器
            启动类加载器
            扩展类加载器
            应用类加载器
            用户自定义的加载器
                为什么会有自定义加载器
                    编译后的代码进行加密,然后再通过实现自己的自定义类加载器进行解密,最后再加载
                    从非标准的来源加载代码。比如从网络来源,那就需要自己实现一个类加载器从指定源进行加载
            对于虚拟机来说，需要完成三件事情
                通过全限定名获取其定义的二进制字节流
                将这个字节流所代表的静态存储结构转为方法区的运行时数据结构
                在Java堆中生成一个代表这个类的java.lang.Class对象作为对方法区中，访问这些数据的入口
            加载时机
                当jvm“预期”到一个类将要被使用时就会在使用它之前对这个类进行加载。
                JVM不是一开始就把所有的类都加载进内存中,而是只有第一次遇到某个需要运行的类时才会加载,且只加载一次。
                常用的hotspot虚拟机是采用的后者,就是说当真正用到一个类的时候才对它进行加载
                JVM在执行代码的过程,每遇到在(运行时数据区-->方法区)找不到类信息的情况都会运行以上的"类加载"流程
    连接
        就是一些加载后的验证工作以及一些初始化前的准备工作。
        具体点就是'把已经读入到内存的类的二进制数据流合并到虚拟机的运行时环境中去'
        验证
            为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
            文件格式验证：
                比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息?
            元数据验证
                比如该类是否继承了被final修饰的类？类中的字段、方法是否与父类冲突？是否出现了不合理的重载？
            字节码验证
                保证程序语义的合理性,比如要保证类型转换的合理性
            符号引用验证
                比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性(private，public等)是否可被当前类访问？
            文件格式验证，基于二进制字节流进行的，只有通过了这个阶段的验证之后,这段字节流才被允许进入Java虚拟机内存的方法区中进行存储。
                所以后面三项验证内容全部是基于方法区的存储结构(内存)上进行的,不会再直接读取操作字节流了
        准备
            为类的静态变量分配内存并设为jvm默认的初值。对于非静态的变量则不会为它们分配内存(实例变量会在对象实例化时随着对象一块分配在Java堆中)
            静态变量的初值为jvm默认的初值而不是我们在程序中设定的初值,jvm默认的初值是Java虚拟机根据不同变量类型的默认初始值
        解析
            jvm把常量池中的符号引用转换为直接引用,解析动作主要针对类或接口、字段、类方法、方法类型等等
            符合引用：即一个字符串,但是这个字符串给出了一些能够唯一性识别一个方法,一个变量,一个类的相关信息
            直接引用：可以理解为一个内存地址或者一个偏移量
                直接指向目标的指针
                相对偏移量
                一个能间接定位到目标的句柄
    初始化
        按照顺序自上而下执行静态变量赋值语句和静态语句,如果有父类,则首先按照顺序运行父类中的按照顺序自上而下执行静态变量赋值语句和静态语句
            所以初始化阶段简单讲就是执行静态相关的语句,具体就是静态属性赋值(为类变量赋予正确的初始值)、静态代码块执行;如果有父类先执行父类的初始化'
        静态语句也就是静态代码块,不包含静态方法这些
    使用
        使用阶段是使用该类所提供的功能,其中包括主动引用和被动引用
        主动引用：
            通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法
            通过反射方式执行以上三种行为
            初始化子类的时候，会触发父类的初始化
            作为程序入口直接运行时（也就是直接调用main方法）
        被动引用：
            引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化
            定义类数组，不会引起类的初始化
            引用类的常量，不会引起类的初始化
    卸载
        该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
        加载该类的ClassLoader已经被回收
        该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法
    阶段的顺序
        加载阶段是类的生命周期中的第一个阶段,加载阶段之后就是连接阶段
            有时连接阶段并不会等加载阶段完全完成之后才开始,而是交叉进行
            但是，遵循：遵循'加载阶段总是在连接阶段之前开始,连接阶段总是在加载阶段完成之后完成'
        存在‘加载或者连接之后没有被初始化就直接被使用’的情况
            加载后跳过连接、初始化2个阶段就直接进入使用阶段
            连接阶段后跳过初始化阶段直接进入使用阶段
        解析
            不一定遵循顺序，可以在初始化时候进行开始，也就是运行时绑定（动态绑定）。
        交叉进行
            这些阶段通常是互相交叉地混合进行的，通常会在一个阶段执行的过程中调用激活另一个阶段

对象的生命周期
    创建的方式：
        直接new出来来
        反射，Class的newInstance()方法
        调用对象的clone
        反序列化
        第三方库

    创建步骤（简版）
        （1）为对象分配存储空间
        （2）开始构造对象
        （3）递归调用其他超类的构造方法
        （4）对象实例化和变量初始化
        （5）指向构造方法体
        创建规则：
            （1）避免在循环体中创建对象
            （2）符合垃圾回收规则
            （3）不要采用过深的继承层次
            （4）访问本地变量优于访问类中的变量。
    创建步骤（完整版）
        （1）判断对象的类是否加载。若没有加载，则先加载、链接、初始化
            当虚拟机接收到一条new指令，会根据这个指令去MetaSpace的常量池找到这个类的符号引用，并检查这个符号引用表示的类是否加载
                如果没有加载，则基于双亲委派机制，则使用当前类加载器以ClassLoader+包名+类名为key查找对应的class文件
                    如果找到则生成对应的class对象，没找到则抛出异常ClassNotFoundException
        （2）为对象分配内存
            如果内存规整，则采用指针碰撞法
                使用过的内存放到一边，没有使用的放到另一边，中间放着指针作为分界点。
                    分配内存时，仅仅是将指针向空闲的那一边移动和对象大小相等的距离。
                    一般带有内存规整的垃圾回收器会采用指针碰撞法
            如果不规整，则采用空闲列表法
                JVM维护了一个列表，记载了哪些内存是可用的，分配时找到一块足够大的对象分配，并更新列表
        （3）处理内存分配过程中的并发问题
            可以采用CAS机制、区域加锁等措施。也可以采用TLAB
        （4）初始化分配好的空间
            默认初始化，给对象所有属性设置默认值，保证对象的实例字段在没有赋值时也可以使用
        （5）设置对象头
            将对象的hashcode,gc，锁信息以及对象的所属类的元数据信息存到对象头中
        （6）执行init方法进行初始化
            显式初始化。类的属性显示初始化，代码块中的初始化，构造器中的初始化。
                编译器会将这几个初始化的过程编译到字节码文件中的init方法
    对象的内存布局
        对象头
            运行时元数据 对象的哈希值，GC年龄计数，锁状态标记，线程持有的锁，偏向时间戳，偏向线程ID
            类型指针 方法区（元空间）中对象所属的数据类型
            如果是数组，还需要保存数组的长度
        实例数据
            真正的有效信息，包括程序定义的各种字段类型和父类继承而来的
        对齐填充

    应用
        对象表现自身能力的阶段，也就是说对象的应用阶段，是对象展现自己，被使用的阶段
        有以下特征
            系统至少维护着一个对象的强引用
            所有对该对象引用的都是强引用（除非我们显式的使用了：软，弱，虚引用）
        四大引用
            强引用
                new就是强引用
                JVM的内存空间不足时，宁愿抛出OutOfMemoryError（溢出异常）使得程序异常终止也不愿意回收具有强引用的存活着的对象！
                只要强引用指向一个目标，垃圾处理器就不会回收这个对象。显示的设置0，null或者超出对象的生命周期，此时就可以回收这个对象
                    具体的回收需要看垃圾回收策略，用不着的对象赋值为null,能够帮助垃圾回收对象回收对象
            软引用（图片缓存，网页缓存）
                有较强的应用功能，只有当内存不足时，才会回收这类内存。
                    这些引用对象可以在程序抛出OutOfMemoryError之前，设置为null;它可以实现一些资源的缓存实现，保证最大限度的使用内存而不引起OutOfMemroy
                    不过虚拟机不鼓励清楚最近访问或使用的软引用
                使用方式
                    A a = new A();
                    SoftReference sr = new SoftReference(a);
                使用场景：
                    软引用使得java可以更好的管理内存，稳定系统。
                    防止系统内存溢出，避免崩溃。
                    因此在处理一些占用内存较大，而且生命周期较长，但是用并不频繁的对象时因该尽量应用该技术。
                    在软引用对象被回收时可以重新被创建。
                    减少内存占用，提高了内存的使用效率，提高系统稳定性。
                    但是对于创建比较复杂，或者占用较多资源的时候，有时候在某些软引用会较低应用的运行效率和性能。
            弱引用（临时数据，内部类引用外部类）
                和软引用最大的不同是：
                    GC回收时，需要通过算法检查是否回收软引用对象
                    弱引用，GC时候总被回收
                    因此weak引用对象会更容易，更快被GC回收。
                回收：
                    虽然GC在运行时一定回收weak引用对象，但是复杂关系的weak对象常常需要好几次回收才能完成。
                    weak引用对象存贮在map数据结构中，引用占用内存空间较大的对象，一旦对象的强引用为null时这个引用就不存在了，GC可以快速的回收这个给对象的空间
                应用：
                    弱引用技术主要适用于实现无法防止其键（或值）被回收的规范化映射，另外，弱引用分为“短弱引用”和“长弱引用”
                    区别在于长弱引用在对象的Finalize方法被GC调用之后依然追踪对象，基于安全考虑，不推荐使用长弱引用
                    ThreadLocal的ThreadLocalMap的Entry就是弱引用
            虚引用
                如果一个对象与虚引用关联，则跟没有引用与之关联一样。
                应用
                    虚引用的用途较少，主要用于辅助finalize函数的使用，
                        Phantom对象指一些执行完了finalize函数，并且为不可达对象，
                        但是还没有被GC回收的对象，这种对象可以辅助finalize进行一些后期的回收工作。
    不可见
        经历过应用阶段，那么该对象就处于不可视阶段，我们在其他区域代码中不再使用它，他的强引用已经消失
        如果一个对象被使用完应该主动将其设置为null，可以在上方的代码下添加obj=null；强制将obj设置为空，可以帮助jvm及时发现这个垃圾对象，并及时回收资源
    不可达
        在虚拟机中所管理的对象引用根本集合中再也找不到直接或简介的强引用，
            这些对象通常是指所有线程栈中的临时变量，
            所有已装载在的类的静态变量或者对本地代码接口的引用。

        这些对象都是要被回收的预备队下，
            但此时该对象并不能被垃圾回收器直接回收，
            其实所有垃圾回收算法面临的问题都是相同的——找出由分配器分配的，但是应用程序不可到达的内存块
    可收集

    终结
    释放
        对象的最后一个阶段，可能处于以下三种情况：
            （1）垃圾回收器发现该对象已经不可到达。
            （2）finalize方法已经被执行。
            （3）对象空间已被重用。
类的加载
    类加载器
        引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等
        扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包
        应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类
        自定义加载器：负责加载用户自定义路径下的类包
    加载顺序：
        加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。
    为什么要双亲委派
        沙箱安全机制：可以防止核心API库被随意篡改
        避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性
    全盘委托
        当一个ClassLoader装载一个类时，该类所依赖及引用的类也由这个ClassLoader载入，除非显示的使用另外一个ClassLoder
    如何认定两个对象同属于一个类型
        同名的类完成实例化
        两个实例各自对应的同名的类的加载器必须是同一个
    自定义类加载器
        继承 java.lang.ClassLoader
            重写loadClass
            重写findClass
    打破双亲委派的两种方式
        重写loadClass，findClass
        SPI（通过线程上下文类加载器的传递性，让父类加载器中调用子类加载器的加载动作）
            spi机制是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。这一机制为很多框架扩展提供了可能，比如在JDBC中就使用到了SPI机制。
            为什么要有SPI：
                在某些情况下父类加载器需要委托子类加载器去加载class文件。
                    受到加载范围的限制，父类加载器无法加载到需要的文件
                由于双亲委派模型，父加载器是拿不到通过子加载器加载的类的。这个时候就需要启动类加载器来委托子类来加载某些类的实现，从而破坏了双亲委派
运行时数据区
    方法区（非堆）
        方法区是所有线程共享的，随着JVM启动而创建，随着JVM关闭而释放
        方法区存储了从.class加载进来的类结构信息，比如：类的运行时常量池，字段和方法数据，以及方法和构造函数的代码。
        包括类、接口初始化和对象实例化中使用的特殊方法

        内存设置：
            方法区占用的物理内存是不连续的。可以通过参数设置。
            异常：
                jdk7:OutOfMemoryError PermGen space
                jdk8：OutOfMemoryError Metaspace
            参数：
                jdk7(永久代)
                    -XX PermSize，永久代的初始大小，默认20.75M
                    -XX MaxPermSize，永久代的最大可分配大小，32位，默认64M，64默认82M
                    在JVM里
                jdk8（元空间）
                    -XX MetaspaceSize
                    -XX MaxMetaspaceSize
                    存储在本地堆中，使用的是本地内存。类型信息、字段、方法、常量保存在本地内存的元空间；
                        字符串常量池，静态变量仍在堆中
        存储内容：
            类型信息
                类的全限定类名，包名.类名
                类的直接父类全限定类名
                类型的修饰符，public final abstract
                该类型的直接接口列表
            静态变量
                非final的static变量。静态变量随着类的加载而加载，是类数据的一部分
            JIT代码缓存
                即时编译后的代码，编译后的代码就是本地代码（硬件相关的），由JIT生成
            方法信息
                保存所有的方法信息，方法名、返回类型、方法的参数数量和类型、方法修饰符、方法的字节码、操作数栈的大小，局部变量表及其大小、异常表
            域信息
                域信息相关信息以及声明的顺序。包括名称、类型和修饰符
            运行时常量池
                class文件常量池：
                    Java源文件被编译class文件之后，就会产生class常量池
                    字节码文件（class文件）常量池，class文件除了类的版本、字段、方法、接口等描述信息之外，还有一个重要的是常量池
                        用于存放编译器生成的各种字面量和符号引用
                        字面量：
                            文本字符串
                            声明的final常量值
                            基本数据类型的值
                            其他
                        符号引用：
                            类和结构的完全限定名
                            字段名称和描述符
                            方法名称和描述符
                    可以看作是一张表，执行虚拟机指令时从这张常量表里找到要执行的类名、方法名、参数类型和字面量信息
                运行时常量池：
                    是方法区的一部分，字节码加载后，即类加载到内存，JVM会将class文件常量池的内容放到运行时常量池。因此运行时常量池是每个类都维护一个。
                    运行时常量池包含多种不同的常量，包括编译期间确定的字面量，也包括运行期间解析得到的方法和字段引用。
                    运行时常量池和class文件常量池区别在于其具备动态性。因运行时也会产生新的常量
                字符串常量池：
                    字符串类单独维护了一个常量池，专门存放String类型的常量。
                    jdk6放在永久代，jdk7放在Java堆中，因为永久代的垃圾回收效率低，只在full gc时候触发。
                        如果大量字符串被创建，且回收效率低，则会导致永久代内存不足，OOM。放到堆中可以及时回收。
                    jdk8方法区的实现变成了元空间，但是字符串还是存放在堆中。
                    字符串常量池全局唯一
    程序计数器
        用来存储指向下一条指令的地址。有了程序计数器，字节码执行引擎就可以一条条读取指令并执行。
        是很小的一块空间，可以忽略不计。但它是运行最快的存储区域。
        每个线程都有自己的程序计数器，其生命周期和线程一致。
        任何时刻，一个线程只能有一个方法来执行，程序计数器会存储当前正在执行的Java方法JVM指令地址。执行native时，则是未指定值
        流程控制都依赖程序计数器。字节码解释器就是通过改变程序计数器的值来选取下一条要执行的字节指令
        是一个唯一没有OutOfMemoryError的区域
    JAVA虚拟机栈
        每个线程创建的时候都会创建一个虚拟机栈，其内部保存了一个个栈帧，对应一个个方法的调用。
        保存方法的局部变量、部分结果、并参与方法的调用和返回
        栈是一种快速有效的内存分配方式，其访问速度仅次于程序计数器
        对于栈来说，不存在垃圾回收问题，因为执行完就出栈了。但是如果方法调用很多，线程请求分配的栈容量超过JVM允许的最大容量，则会抛出StackOverflowError
        可以用-Xss设置线程的最大栈空间大小。栈空间的大小决定了函数调用可以达到的最大深度
        栈帧的内部结构
            局部变量表
                存储方法参数、方法内定义的局部变量。仅在当前方法有效，方法结束之后，随着栈帧的被销毁，局部变量表也被销毁
                方法嵌套的次数由栈的大小决定。但对于方法而言，参数和局部变量越多，栈越大，嵌套的次数也就越少
                局部变量表中的变量也是垃圾回收时的重要根节点（GC Roots），即只要是被局部变量表中的变量直接或间接引用的对象不会被垃圾回收掉
            操作数栈
                也成为表达式栈，在方法执行过程中根据字节码的指令往栈里写入数据或者读取数据，即入栈和出栈。
                就是代码执行过程中，计算逻辑在计算过程中产生的一些中间结果，这些中间结果就存在操作数栈，同时作为计算过程中变量的临时存储空间
                我们说的JVM解释器引擎是基于栈的执行引擎，这里的栈就是操作数栈
            动态链接
                每个栈帧内部都包含了一个指向运行时常量池中该栈帧所属方法的引用。有了这个引用，当前方法就能实现动态链接。一个方法调用另一个方式时，
                就是通过常量池中指向方法的符号引用。
                动态链接的作用就是将所有的符号引用转为调用方法的直接应用
            方法返回地址
                存放调用该方法的程序计数器的值。
                方法执行完毕退出后，都应该返回到该方法被调用的位置。
                因此正常退出后，应该将调用者的程序计数器的值作为返回地址，即调用该方法的指令的下一个指令的地址。
                异常退出时，返回地址根据异常表来确定
            一些附加信息
                JVM实现相关的一些信息，如程序调试提供的支持
    本地方法栈
        调用非Java语言实现的接口。初衷是融合C、C++程序，实现Java与底层的一些交互，能够使用一些Java没有封装的提供操作系统的一些特性
        调用本地方法，就进入了一个不受JVM限制的世界，甚至和JVM有同样的权限
    堆区
        运行时数据区最重要的一个区域，也是占用内存最大的
        物理上可以不连续，但是逻辑上应视为连续。
        堆空间在JVM启动时确定，可以通过参数进行设置。
        堆空间是被所有线程共享，但是内部可以划分一小部分作为线程私有的缓冲区，每个线程一份
        所有类的实例（对象）和数组都会在运行时分配到堆上。在Java方法结束时，堆中的对象不会立即被移除，而是执行垃圾回收时，才会被清除（栈上分配的对象除外）
        举例：
            Book book = new Book()
            类型信息存储在方法区
            book存储在虚拟机栈，保存了一个引用，指向对象在堆中的位置
            new Book()存储在堆中，同时保存一个对象数据的指针并指向方法区
        堆是JVM内存管理的核心区域，也是执行垃圾回收（GC）的重点区域。
        堆的分代思想：
            jdk7：新生代，老年代，永久代；其中新生代被分为：伊甸园区、幸存者1区、幸存者2区
            jdk8：新生代，老年代，元空间；元空间对应的jdk7的永久代
        为什么分代：
            通过分代，将共同特征的对象放到一起，这样GC效率会提高很多。
            生命周期短的在新生代，长的在老年代；需要针对性的采用不同的垃圾回收策略区别性对待
        对象的分配过程
            （1）new出来的对象首先会放在伊甸园区
            （2）伊甸园区满了之后，再创建对象，JVM会对伊甸园区进行垃圾回收，将没有引用指像的对象清除之后，
                再放入新的对象到伊甸园区
            （3）将伊甸园区剩余的，未被回收的对象放到幸存者0区
            （4）再次触发GC时， 上次放入幸存者0区的，如果没有被回收，将会复制到幸存者1区
            （5）如果再次经历垃圾回收，没有被回收的对象又会回到幸存者0区，就这样一直往复
            （6）来回往复的次数达到15次，则进入老年代。参数是 -XX MaxTenuringThreshold=15
            （7）在老年代的对象，垃圾回收的频率远小于年轻代。当老年代内存不足时，再次出发垃圾的回收，清理对象
            （8）如果老年代已经执行了垃圾回收的前提下，空间依然不足以存放对象，则会抛出OOM，java.lang.OutOfMemoryError：Java head space
            垃圾回收原则：频繁回收新生代，较少回收老年代，几乎不动永久代/元空间
        内存分配策略
            新的对象都现在Eden分配，如果经过第一次年轻代垃圾回收（GC）仍然存活，且能被Survivor放得下的话就被移到Survivor空间，并且对象年龄设置为1。
            之后对象在Survivor空间没经历依次GC，年龄增加1。当年龄增加一定阈值，就会晋升到老年代。
            规则：
                优先分配Eden
                大对象直接分配到老年代
                长期存活对象分配到老年代
                如果Survivor区所有相同年龄的的对象大小之和大于空间的一半，则大于等于该年龄的对象直接进入老年代，无需等到设置的默认次数
    TLAB（Thread Local Allocation Buffer）
        线程本地分配缓存区，是线程私有的分配区。堆区是线程共享的，如果对象创建速度非常频繁，并发环境中的区域划分内存空间会产生线程安全问题。
        为了避免这个问题需要引入锁机制，会影响分配的速度。因此从Eden区划分很小的一块区域作为线程私有的的缓存区域TLAB
        如果设置了JVM参数，-XX UseTLAB，则每个线程初始化时都会申请一块指定大小的内存，给当前线程使用。这样在同时分配内存时，各个线程都在
        自己的空间分配，不存在竞争，能提高分配的吞吐量。TLAB的内存占用非常小，默认只有Eden的1%，可以使用-XX TLABWasteTargetPercent
        设置TLAB作为对象内存分配的首选
    堆空间参数设置：
        -Xms 初始堆大小，默认为物理内存的1/64，比如设置100m，-Xms100m
        -Xmm 最大堆大小，默认为物理内存的1/4，比如设置1g,-xms1024m
        -xmn 新生代的大小，等价于-XX:NewSize，比如-XX:NewSize=256m和-XX256m都是设置新生代的大小为256m
        -XX:NewRadio 老年代和的新生代堆空间的比例大小，默认是2，
        -XX:SurvivorRadio 新生代中Eden和s0、s1的比例，默认是8:1:1，也就是说s0和s1需要相等
        -XX:MaxTenuringThreshold 新生代年龄的阈值，默认是15
        -XX:PrintGCDetails：输出详细的GC日志，默认是关闭的
    逃逸分析
        Java编译器能够分析出一个对象的引用范围从而决定是否将该对象分配到栈上还是堆上。
            如果一个方法在定义之后，仅在方法内部使用，则认为没有逃逸；
            如果为外部方法所用，则认为发生逃逸
        jdk6之后Hotspot默认开启逃逸分析，可以通过-XX:-DoEscapeAnalysis关闭
        逃逸分析自身也需要进行复杂的分析，也是一个耗时的过程。

    直接内存
        不是JVM运行时数据的一部分，规范中也没有定义内存区域。
        是Java堆外，直接向操作系统申请的内存区域。NIO可以通过DirectByteBuffer可以操作Native内存
        好处就是可以避免数据在内核空间缓冲区和用户空间缓冲区之间拷贝，因此性能优于Java堆内存。
            频繁读写之下可以优先使用直接内存
        因不受JVM管理，回收成本比较高。
        直接内存可以通过MaxDirectMemorySize设置，默认与堆最大值参数（-Xmx）指定的一致
    执行引擎
        作用就是将字节码指令解释、编译为可执行的本地机器指令
        解释器：
            根据JVM规范对字节码进行解释执行，即将每条字节码指令转换为平台对应的本地机器指令执行
        编译器：
            JIT编译器（即时编译器），将源代码直接编译为平台对应的本地机器码
        HotSpot采用解释器和编译器并存的架构，其相互协作，取长补短。权衡编译代码和JIT的耗时，采用最优方式
        当JVM启动时，解释器先发挥作用，而不必等待JIT全部编译完成。
            这样可以节省很多不必要的编译时间。
        随着程序的运行，JIT逐渐发挥作用，它会根据热点代码的探测结果，将热点代码编译为本地机器指令，提高程序的效率
        相关参数：
            -Xint 完全采用解释器
            -Xcomp 完全采用JIT
            -Xmixed 解释器+即时编译（JIT）
        扩展：
            正式因为JIT，java才有了预热一说，程序刚跑起来，大部分都是解释执行的，一段时间之后，存到JIT代码缓存中，
                后续这部分程序的执行就是直接运行编译好的机器码，因此程序的性能主键提升

垃圾回收

日志分析（dump）

动态代理