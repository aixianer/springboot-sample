解决的问题
    1、消费者如何获取服务这提供的地址信息
    2、如果有多个服务提供者，消费者该如何选择
    3、消费者如何得知服务提供者的健康状况
主要功能
    注册：就是将提供某个服务的模块信息(通常是这个服务的ip和端口)注册到1个公共的组件
    发现：这个服务模块能够及时的被其他调用者发现。不管是服务新增和服务删减都能实现自动发现。
    健康状况：确认服务状态是否健康，一般通过心跳检测来续约
注册模式
    1、自注册模 式
        每个服务启动后，需要到统一的服务注册中心进行注册登记，服务正常终止后，也可以到注册中心移除自身的注册记录。
        在服务执行过程中，通过不断的发送心跳信息，来通知注册中心，本服务运行正常。
        注册中心只要超过一定的时间没有收到心跳消息，就可以将这个服务状态判断为异常，进而移除该服务的注册记录
    2、三方注册模式
        健康检查的动作不是有服务本身(client)来负责，而是由其它第三方服务来确认。
        因为可能服务本身已经存在故障，某些接口功能不可用，但仍然可以不断的发送心跳信息，导致注册中心没有发觉该服务已经异常
发现模式
    服务消费者从服务注册表获取服务提供者的最新网络位置等服务信息，维护与服务提供者之间的通信。
    服务发现机制的关键部分是注册中心。
    注册中心提供管理和查询服务注册信息的API。
    当服务提供者的实例发生变更时（新增/删除服务），服务注册表更新最新的状态列表，并将其最新列表以适当的方式通知给服务消费者。
    （1）客户端发现模式
        如果要进行微服务调用，首先要进行的是到服务注册中心获取服务列表，然后再根据调用端本地的负载均衡策略，进行服务调用。
        过程如下：
            1、 服务提供者向注册中心进行注册，提交自己的相关信息
            2、 服务消费者定期从注册中心获取服务提供者列表
            3、 服务消费者通过自身的负载均衡算法，在服务提供者列表里面选择一个合适的服务提供者，进行访问
        优点：
            1、服务客户端可以灵活、智能地制定负载均衡策略，包括轮询、加权轮询、一致性哈希等策略
            2、可以实现点对点的网状通讯，即去中心化的通讯。可以有效避开单点造成的性能瓶颈和可靠性下降等问题。
            3、服务客户端通常以SDK的方式直接引入到项目，这种方式语言的整合程度最佳，程序执行性能最佳，程序错误排查更加容易。
        缺点：
            1、当负载均衡算法需要更新时候，很难做到同一时间全部更新，所以就造成新旧算法同时运行
            2、与注册中心紧密耦合，如果要换注册中心，需要去修改代码，重新上线。微服务的规模越大，服务更新越困难，这在一定程度上违背了微服务架构提倡的技术独立性。
    （2）服务端发现模式
        调用方直接向服务注册中心进行请求，服务注册中心再通过自身负载均衡策略，对微服务进行调用。这个模式下，调用方不需要在自身节点维护服务发现逻辑以及服务注册信息。
        过程如下:
            1、 服务提供者向注册中心进行服务注册
            2、 注册中心提供负载均衡功能，
            3、 服务消费者去请求注册中心，由注册中心根据服务提供列表的健康情况，选择合适的服务提供者供服务消费者调用

        现代容器化部署平台（如Docker和Kubernetes）就是服务端服务发现模式。
        这些部署平台都具有内置的服务注册表和服务发现机制。
        容器化部署平台为每个服务提供路由请求的能力。
        服务客户端向路由器（或者负载均衡器）发出请求，容器化部署平台自动将请求路由到目标服务一个可用的服务实例
        优点：
            服务消费者不需要关心服务提供者的列表，以及其采取何种负载均衡策略
            负载均衡策略的改变，只需要注册中心修改就行，不会出现新老算法同时存在的现象
            服务提供者上下线，对于服务消费者来说无感知
        缺点：
            rt增加，因为每次请求都要请求注册中心，尤其返回一个服务提供者
            注册中心成为瓶颈，所有的请求都要经过注册中心，如果注册服务过多，服务消费者流量过大，可能会导致注册中心不可用
            服务端发现模式实际上是集中式的做法，如果路由器或者负载均衡器无法提供服务，那么将导致整个系统瘫痪。

eureka框架
    1、介绍
        Eureka是Netflix公司开发的服务注册与发现框架，SpringCloud将Eureka集成到子项目Spring-Cloud-Netflix中实现服务注册与发现功能，、
    2、工作原理
        Eureka Server：
            服务注册发现服务器，也称为服务注册中心，各个服务启动后，会在Eureka Server中进行注册，这样Eureka Server 的服务注册表中将会存储所有可用服务节点的信息。
        Eureka Client ：
            也称微服务，作为一个Java客户端，用于简化与Eureka Server的交互。
            Eureka Client内置一个使用轮询负载算法的负载均衡器。
            服务启动后，Eureka Client 将会向Eureka Server发送心跳更新服务，如果Eureka Server 在多个心跳周期内（默认90秒）没有接收到某个服务的心跳，Eureka Server 就将会从服务注册表中把这些服务节点移除
    3、Eureka Client的两种角色：消费者和提供者
        服务消费者：
            用于获取Eureka Server注册的服务清单，并且该服务清单默认每隔30秒更新一侧。
            服务消费者获取到服务清单后，能够根据自己的需求决定调用哪个服务，默认采用轮询方式调用，从而实现Eureka Client的负载均衡。
        服务提供者
            Eureka Client 启动后，服务提供者会通过REST请求将自己注册在Eureka Server中，并维护一个心跳进行 服务续约，
            告诉Eureka Server自己还”存在，防止被Eureka Sever 将该服务从服务列表中剔除。
    4、DiscoveryClient接口
        DiscoveryClient接口是SpringCloud框架提供的，主要为了扩展Netflix提供的Eureka客户端而提供的，该接口的实现类通过组合的方式引入了Netflix提供的DiscoveryClient类
        四个实现类
            1、EurekaDiscoveryClient，主要用来当Eureka作为注册中心进行管理服务实例时使用
            2、CompositeDiscoveryClient，是一个组合器，主要用来组合多种DiscoveryClient实现，具体还是交给其他DiscoveryClient实现类进行处理
            3、SimpleDiscoveryClient，主要用来当使用属性文件管理服务实例的场景
            4、NoopDiscoveryClient，已经被标记过期
ribbon
    1、是什么
        Ribbon是Netflix发布的云中间层服务开源项目，其主要功能是提供客户端实现负载均衡算法。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等
        Ribbon是一个客户端负载均衡器，我们可以在配置文件中Load Balancer后面的所有机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器，我们也很容易使用Ribbon实现自定义的负载均衡算法。
    2、如何使用
        RestTemplate配置类添加@LoadBalanced注解
    3、策略
        （1）RoundRobinRule：
            简单轮询服务列表来选择服务器，它是Ribbon默认的负载均衡策略
        （2）AvailabilityFilterRule
            对以下两种服务器进行忽略：
                （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态，短路状态将持续30秒，如果再次连接失败，短路持续时间就会几何级地增加。
                （2）并发数过高的服务器，如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的ActiveConnectionsLimit进行配置。
        （3）WeightedResponseTimeRule
            为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重会影响服务器的选择。
        （4）ZoneAvoidanceRule
            以区域可用的服务器为基础进行服务器的选择，使用Zone对服务器进行分类，这个Zone可用理解为一个机房，一个机架等。而后再对Zone内对多个服务做轮询。
        （5）BestAvailableRule
            忽略那些短路等服务器，并选择并发数较低的服务器
        （6）RandomRule
            随机选择一个可用的服务器
        （7）RetryRule
            重试机制的选择逻辑
    4、配置方式
        （1）代码：
            启动类Application中
            @Bean
            public IRule randomRule(){
                return new RandomRule();
            }
        （2）代码：
            @Configuration
            public class MyRule {
                @Bean
                public IRule randomRule(){
                    //替换为随机算法
                    return new RandomRule();
                }
            }
            启动类： @RibbonClient(name ="服务名" ,configuration = RibbonConfig.class)
        （3）配置文件
            userservice:
              ribbon:
                NFLoadBanlancerRuleClassName: com.netflix.loadbalancer.RandomRule #负载均衡规则
    5、饥饿加载
         Ribbon默认的是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载。
         ribbon:
           eager-load:
             enabled: true #开启饥饿加载
             clients: userservice   #制定对userservice这个服务饥饿加载

RestTemplate
    1、介绍
        RestTemplate是一个执行HTTP请求的同步阻塞式工具类，它仅仅只是在 HTTP 客户端库（例如 JDK HttpURLConnection，Apache HttpComponents，okHttp 等）基础上，封装了更加简单易用的模板方法 API，方便程序员利用已提供的模板方法发起网络请求和处理，能很大程度上提升我们的开发效率
        默认使用了JDK自带的HttpURLConnection作为底层HTTP客户端实现
    2、改造默认的HttpURLConnection实现
        （1）改造1
            @Bean
            public RestTemplate restTemplate(){
                RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory());
                return restTemplate;
            }

            /**
             * 使用HttpClient作为底层客户端
             * @return
             */
            private ClientHttpRequestFactory getClientHttpRequestFactory() {
                int timeout = 5000;
                RequestConfig config = RequestConfig.custom()
                        .setConnectTimeout(timeout)
                        .setConnectionRequestTimeout(timeout)
                        .setSocketTimeout(timeout)
                        .build();
                CloseableHttpClient client = HttpClientBuilder
                        .create()
                        .setDefaultRequestConfig(config)
                        .build();
                return new HttpComponentsClientHttpRequestFactory(client);
            }

            private ClientHttpRequestFactory getClientHttpRequestFactory(){
                OkHttpClient okHttpClient = new OkHttpClient.Builder()
                        .connectTimeout(5, TimeUnit.SECONDS)
                        .writeTimeout(5, TimeUnit.SECONDS)
                        .readTimeout(5, TimeUnit.SECONDS)
                        .build();
                return new OkHttp3ClientHttpRequestFactory(okHttpClient);
            }
            OkHttp>HttpClient>HttpURLConnection
        （2）改造2
            @Bean
            public HttpComponentsClientHttpRequestFactory requestFactory() {
                PoolingHttpClientConnectionManager connectionManager =
                        new PoolingHttpClientConnectionManager(30, TimeUnit.SECONDS);
                connectionManager.setMaxTotal(200);
                connectionManager.setDefaultMaxPerRoute(20);

                CloseableHttpClient httpClient = HttpClients.custom()
                        .setConnectionManager(connectionManager)
                        .evictIdleConnections(30, TimeUnit.SECONDS)
                        .disableAutomaticRetries()
                        // 有 Keep-Alive 认里面的值，没有的话永久有效
                        //.setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy.INSTANCE)
                        // 换成自定义的
                        .setKeepAliveStrategy(new CustomConnectionKeepAliveStrategy())
                        .build();

                HttpComponentsClientHttpRequestFactory requestFactory =
                        new HttpComponentsClientHttpRequestFactory(httpClient);

                return requestFactory;
            }

            @LoadBalanced
            @Bean
            public RestTemplate restTemplate(RestTemplateBuilder builder) {
                return builder
                        .setConnectTimeout(Duration.ofMillis(100))
                        .setReadTimeout(Duration.ofMillis(500))
                        .requestFactory(this::requestFactory)
                        .build();
            }
    3、常用方法
        （1）GET请求
            getForObject():返回值是HTTP协议的响应体
            getForEntity():返回的是ResponseEntity，ResponseEntity是对HTTP响应的封装，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息
            示例：
            直接发起：
                ResponseBean responseBean = restTemplate.getForObject(url, ResponseBean.class);
                ResponseEntity<ResponseBean> response = restTemplate.getForEntity(url, ResponseBean.class);
            带参数发起：
                ResponseBean responseBean = restTemplate.getForObject(url, ResponseBean.class, "001", "张三");
            header参数：
                //请求头
                HttpHeaders headers = new HttpHeaders();
                headers.add("token", "123456789");
                //封装请求头
                HttpEntity<MultiValueMap<String, Object>> formEntity = new HttpEntity<>(headers);
                ResponseEntity<Map> exchange = restTemplate.exchange('请求的url', HttpMethod.GET, formEntity, Map.class);
        （2）POST请求
            postForObject():返回body对象
            postForEntity():返回全部的信息

             HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(map, headers);
            //发起请求
            ResponseBean responseBean = restTemplate.postForObject(url, request, ResponseBean.class);

             //入参
            RequestBean request = new RequestBean();
            request.setUserName("唐三藏");
            request.setUserPwd("123456789");

            //发送post请求，并打印结果，以String类型接收响应结果JSON字符串
            ResponseBean responseBean = restTemplate.postForObject(url, request, ResponseBean.class);
            System.out.println(responseBean.toString());

Feign
    是什么
        一个http请求调用的轻量级框架，是以Java接口注解的方式调用Http请求，而不用像Java中通过封装HTTP请求报文的方式直接调用。
        Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，
        封装了Http调用流程，更符合面向接口化的编程习惯
        Spring Cloud集成Feign并对其进行了增强，使Feign支持了Spring MVC注解；Feign默认集成了Ribbon，所以Fegin默认就实现了负载均衡的效果。
    原理
        1、将feign接口的代理类扫描到Spring容器中：
            @EnableFeignClients开启feign注解扫描：FeignClientsRegistrar.registerFeignClients()扫描被 @FeignClient标识的接口生成代理类，并把接口和代理类交给Spring的容器管理。
        2、为接口的方法创建RequestTemplate
            当consumer调用feign代理类时，代理类会调用SynchronousMethodHandler.invoke()创建RequestTemplate(url，参数)
        3、发出请求
            代理类会通过RequestTemplate创建Request，然后client(URLConnetct、HttpClient、OkHttp)使用Request发送请求
    实现过程：
        开启Feign功能：
            @EnableFeignClients
        Feign的客户端：
            @FeignClient(value = "provider-service",path="/order",contextId="？？")
            public interface ConsumerService {
                //String url = String.format("http://provider-service/user/findUserById/%s",id);
                @RequestMapping("/user/findUserById/{id}")
                User findUserById(@PathVariable("id") Integer id);

            }
    Feign优化
    （1）请求压缩（gzip）
            支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗
            feign:
                compression:
                    request:
                        enabled: true # 开启请求压缩
                    response:
                        enabled: true # 开启响应压缩
            触发压缩的大小下限
            feign:
                compression:
                    request:
                        enabled: true # 开启请求压缩
                        mime-types:	text/html,application/xml,application/json # 设置压缩的数据类型
                        min-request-size: 2048 # 设置触发压缩的大小下限
    （2）开启feign日志
    （3）feign超时问题
    （4）http连接池
其他
    Spring Cloud的五大组件:
        服务发现-Netflix Eureka
        客服端负载均衡-Netflix Ribbon
        断路器-Netflix Hystrix
        服务网关-Netflix Zuul / gateway
        分布式配置-Spring Cloud Config
