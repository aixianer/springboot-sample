异常：
    Throwable
        Error
            通常环境下不希望被程序捕获的异常。Error 类型的异常用于 Java 运行时由系统显示与运行时系统本身有关的错误。堆栈溢出是这种错误的一例。
            如堆栈溢出、死锁
        Exception
            Exception 类用于用户程序可能出现的异常情况，它也是用来创建自定义异常类型类的类。
            受检查异常
                IO相关的，ClassNotFoundException，CloneNotSupportedException
                该异常我们必须手动在代码里添加捕获语句来处理该异常
            运行时异常（RuntimeException）
                NullPointerException、IndexOutOfBoundsException、数组越界、除以0
泛型
    泛型的本质是为了将类型参数化， 也就是说在泛型使用过程中，数据类型被设置为一个参数，在使用时再从外部传入一个数据类型；
    而一旦传入了具体的数据类型后，传入变量（实参）的数据类型如果不匹配，编译器就会直接报错。这种参数化类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
    小结：
        与使用 Object 对象代替一切引用数据类型对象这样简单粗暴方式相比，泛型使得数据类型的类别可以像参数一样由外部传递进来。它提供了一种扩展能力，更符合面向对象开发的软件编程宗旨。
        当具体的数据类型确定后，泛型又提供了一种类型安全检测机制，只有数据类型相匹配的变量才能正常的赋值，否则编译器就不通过。所以说，泛型一定程度上提高了软件的安全性，防止出现低级的失误。
        泛型提高了程序代码的可读性。在定义泛型阶段（类、接口、方法）或者对象实例化阶段，由于 < 类型参数 > 需要在代码中显式地编写，所以程序员能够快速猜测出代码所要操作的数据类型，提高了代码可读性。
    使用方式：泛型类、泛型接口、泛型方法
        （1）泛型类
            类型参数用于类的定义中，则该类被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map等。
            泛型类中的静态方法和静态变量不可以使用泛型类所声明的类型参数
            静态泛型方法中可以使用自身的方法签名中新定义的类型参数（即泛型方法，后面会说到），而不能使用泛型类中定义的类型参数。
            泛型类不只接受一个类型参数，它还可以接受多个类型参数
    ·   （2）泛型接口
            泛型接口中的类型参数，在该接口被继承或者被实现时确定。
            在泛型接口中，静态成员也不能使用泛型接口定义的类型参数。
            定义一个接口 IA 继承了 泛型接口 IUsb，在 接口 IA 定义时必须确定泛型接口 IUsb 中的类型参数。
            定义一个类 BB 实现了 泛型接口 IUsb，在 类 BB 定义时需要确定泛型接口 IUsb 中的类型参数。
            定义一个类 CC 实现了 泛型接口 IUsb 时，若是没有确定泛型接口 IUsb 中的类型参数，则默认为 Object。
        （3）泛型方法
            当在一个方法签名中的返回值前面声明了一个 < T > 时，该方法就被声明为一个泛型方法。< T >表明该方法声明了一个类型参数 T，并且这个类型参数 T 只能在该方法中使用。当然，泛型方法中也可以使用泛型类中定义的泛型参数。
            public <类型参数> 返回类型 方法名（类型参数 变量名） {
                ...
            }
            只有在方法签名中声明了< T >的方法才是泛型方法，仅使用了泛型类定义的类型参数的方法并不是泛型方法。
            泛型方法中可以同时声明多个类型参数。
            泛型方法中也可以使用泛型类中定义的泛型参数。
            特别注意的是：泛型类中定义的类型参数和泛型方法中定义的类型参数是相互独立的，它们一点关系都没有。
            泛型类，在创建类的对象的时候确定类型参数的具体类型；
            泛型方法，在调用方法的时候再确定类型参数的具体类型。
    类型擦除
        泛型的本质是将数据类型参数化，它通过擦除的方式来实现，即编译器会在编译期间擦除代码中的所有泛型语法并相应的做出一些类型转换动作。
        泛型信息只存在于代码编译阶段，在代码编译结束后，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。也就是说，成功编译过后的 class 文件中不包含任何泛型信息，泛型信息不会进入到运行时阶段。
