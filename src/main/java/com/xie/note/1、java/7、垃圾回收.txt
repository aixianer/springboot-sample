GC日志分析（https://bigbird.blog.csdn.net/article/details/119305776）
    GC的分类
        部分收集（Partial GC）
            新生代（Minor GC/Young GC）:只是针对新生代（Eden、S0、S1）的垃圾回收
            老年代（Major GC/Old GC）：老年代的回收。目前之后CMC垃圾回收器才有单独收集老年代的行为
            混合（Mixed GC）:收集整个新生代和部分老年代。目前只有G1收集器才有这种行为
        整堆收集
            收集整个Java堆以及方法去。有时候Major GC也被当作是Full GC

    GC日志结构
        垃圾回收期的标志
        GC前后空间的占用情况
        GC时间
    Minor GC日志分析
    Full GC日志分析

内存泄漏（https://bigbird.blog.csdn.net/article/details/119305806）
    定义
        所谓内存泄漏，一般是指对象不再需要使用了，但是垃圾回收期却不能回收他们，这就发生了内存泄漏
        有一些对象声明周期比较长的也可能发生内存泄漏
        随着内存泄漏的增多，最终会导致内存溢出
    内存泄漏的场景
        静态集合类
            静态类型，他们的声明周期将与JVM进程一致。
            换言之，集合存放的对象实例在程序终止前不能被释放掉，从而引发内存泄漏
            单例模式，单例模式静态特性，如果单例对象持有外部对象的引用，那么整个外部类对象也不能被回收
        内部类持有外部类
            一个外部类的对象的方法返回了一个内部类的实例对象，那么当整个内部类对象被长期引用时，及时哪个外部类实例对象不再被显示的引用。
            但是由于内部类对象会隐式持有外部类对象的引用，这就造成外部类的对象这是种不满足GC的回收台哦见
        不合理的变量作用域
            缩小变量的作用域
        各种IO链接
            程序中各种外部资源的链接，如网络Socket连接、数据库连接、文件IO连接等；
            如果不再使用，需要将其关闭。
            只有关闭后，GC才会回收相应的对象
        改变对象的哈希值
            一些集合类的操作，如果堆元素操作前后改变了元素的hashcode，可能导致删除失败，导致泄漏
    定位问题
        定位java进程OOM
            堆内存OOM问题
                最直接的办法是，适当调大xms xmx后重启应用，但是如果无效，可以按以下步骤
                    生成堆内存的dump文件
                        启动时添加tump参数，当oom发生时，自动dump堆转储文件
                            -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath= /usr/logs/app.bin
                        手动dump,使用jmap -dump命令
                            jmap -dump:live,format=b,file=<dump path> <pid>
                            注意：伤处命令会触发一次Full GC.建议多管擦混现场监控数据，如发现意思内存泄漏，尽早dump，降低full GC时间
                    分析堆内存的dump文件
                        可以使用MAT或者前文介绍的任意工具做dump分析
                        MAT可以直接生成内存泄漏报告，列出存在内存泄漏的可疑点
            堆外内存OOM
                有时我们发现Java进程莫名的消失了。查看日志也没有异常信息，也没有堆内OOM的痕迹
                当机器内存不足时候，操作系统wield而保证系统正常运行，会把占用内存最大的进程杀死
                可以查看操作系统的日志验证。linux的主配置文件/etc/rsyslog.conf中设置了将内核消息以及各种系统程序消息记录到什么位置
                    默认是/var/log/messages
                可以使用NMT功能来分析Java进程哪部分占用过大导致OOM
                    NMT
                        jdk7引入的新功能，跟踪java内存使用情况。可以追踪到堆内存、code区域以及通过unsafe.allocateMemory和DirectByteBuffer
                        申请的内存，详细记录java进程内存的使用情况

                        如需排查内存问题可以开启此功能，然后崇高和内心穷的那个java。启动此功能会造成5-10%的性能所示，因此默认是关闭的
                        参数：
                            开启：-XX:NativeMemoryTracking=＜summary | detail＞
                            打印日志：
                                jcmd <pid> VM.native_memory detail scale=MB
            方法栈OOM
                一般是由于程序中存在死循环或者递归调用深度太大导致，占空间的大小设置太小也可能会出现此种溢出
                可以通过-Xss设置线程占的大小

        定位CPU负载过高
            top+jstack命令组合来顶问线程问题
            步骤：
                （1）top查看个进程的cpu使用情况，默认按照cpu使用率排序，锁定cpu占用率较高的进程PID
                （2）top -Hp <pid>查看上述步骤中该进程下各线程CPU使用情况
                （3）找出cpu使用率较高的线程PID，并转成16禁止，printf '%x'
                （4）使用jstack <pid>查看第一步的cpus使用率较高的java进程堆栈状态，并找到nid和上一步转好的16进制相同的线程日志
                （5）查看线程堆栈日志定位到执行的代码
                （6）隔段时间再执行一次jstack命令获取thread dump，比较观察是否又有一段相同的代码
垃圾回收
    对象的finalization机制
        Java应用和层序可以使用对象终止来允许开发热源提供兑现刚被销毁前的自定义逻辑处理
        垃圾回收期回收一个对象之前，总是会先调用这个对象的finalize()方法
        Object对象的finalize()方法允许被子类重写，用于在对象被回收前进行最后的处理，比如释放某些资源：关闭文件、socket、数据库连接
        不建议手动调用某个对象的finalize方法，一共由垃圾回收机制掉调用，因为:
            （1）finalize方法中，可能导致对象复活
            （2）finalize的执行时间没有保障的，完全由GC西安测绘给你据欸的那个。极端情况下，若不发生GC，则finalize方法永远得不到执行
            （3）一个糟糕的finalize方法会严重影响GC的性能。可能有耗时的操作
        因为finalization机制的存在，JVM的对象有三种状态：
            （1）可触及的：从根节点搜索，可以到达整个对象
            （2）可复活的：对象的所有引用都被释放，但是可能在finalize方法中被复活
            （3）不可触及的：对象的finalize方法已经调用，但是没有在finalize方法中复活该对象，那么该对象就会进入不可触及的状态
                不可触及的对象不能被复活，因为finalize方法只能被调用一次
        只有不可触及的状态的对象才能被回收
            因此一个对象X是否被回收，至少经理2次标记的过程：
                （1）如果一个对象X到GC Roots没有任何引用链，则进行首次标记
                （2）进行筛选，判断此对象是否需要执行finalize方法
                    如果对象X没有重写finalize方法或者finalize方法已经被调用过一次，则JVM判定为没有必要执行，对象X被判断各位不可触及的
                    如果对象X重写了finalize方法，且还未执行过，那么对象X会被插入到一个称之为F-Queue的队列中，稍后由JVM创建的地邮件及的Finalizer线程触发其finalize方法
                    finalize是对象逃脱死亡的最后机会，稍后垃圾回收期会对F-Queue中的对象进行二次标记。如果对象X在finalize方法中与引用链上任何一个对象建立了来呢西，
                        那么二次标记时，就会被移除。之后对象X再次出现没有引用指向的时候，兑现给X的状态变为不可触及状态，因为finalize方法只能被调用1次。没有第二次逃亡的机会了
        System.gc()
            手动调用Sysetem.gc()或者Runtime.getRuntime.gc()来显示触发GC，同时对老年代和新生代进行回收，尝试释放死亡对象所占用的内存‘
            但是垃圾回收是否真的会执行还是取决于JVM的实现，因为有个免责声明：无法保证对垃圾收集器的调用
            什么场景下会使用.gc()
                编写性能基础测试时候，可能会用到垃圾回收

STW
    stop the world。指的是GC时间发生时候，会产生应用程序的停顿。即应用工程徐的线程被毁暂停，没有任何响应，有种卡死的感觉
    为什么
        为了保证一致性
    比如在可达性分析算法种美剧跟系欸但时，就需要所有的Java西安测绘给你暂停，一位内分析工作必须在一个确保一致性的块中进行。
        所谓的一致性就是在分析期间，对象的引用关系不能再不断地变化，否则无法保证分析结果的准确性。
    被垃圾回收过程中的STV暂停的用户贤臣国会在GC完成后护肤。如果终端频繁，就会让用户感受到卡顿。所有进来给你减少垃圾回收过程的STW的产生
    所有的垃圾回收器都有STW事件，只能说随着垃圾回收器的发展，回收效率越来越高，尽可能缩短了停顿的时间
    STW是由JVM自身发起、自动完成的。因此，实际开发中非必要不建议手动调用.gcc()

垃圾回收的并行与并发
    垃圾回收语境下的释义：
        并行
            多条垃圾回收线程同时工作，但此时用户线程仍处于等待状态
            ParNew、Parallel、Scavenge、Parallel Old收集器
        串行
            相对于并行的概念，是单线程执行。如果内存不够，则应用程序暂停，启动JVM的垃圾回收线程进行垃圾回收。
                回收完成之后再启动应用程序线程
        并发
            用户线程和垃圾回收线程同时执行（不一定是并行，可能是交替分片执行），垃圾回收线程的执行不会停顿用户线程的运行。
                用户程序继续运行，而垃圾收集线程再另外的CPU。比如CMS和G1收集器
安全点和安全区域
    程序执行并非再任何地方都能停下执行GC，只有特定的位置才能停下来执行GC，这些位置被称为安全点。
    安全点是程序执行期间所有的GC Root已知并且所有堆对象的内容一致的点。
    当线程运行到安全点位置时，堆对象状态时一致的、确定的，JVM可以安全地进行各种操作，比如执行垃圾回收，解除偏向锁等。
    如何许安则安全点呢？
        如果安全点太多，或导致GC频繁，增大程序运行符合；
        太少，单次GC等待时间可能会长。
        比如：
            方法调用之后，返回之前
            抛出异常，即异常跳转位置
            循环跳转，即循环的末尾的位置
        选择上述位置的目的就是避免程序长时间无法进入Safa Point。JVM在执行GC之前要等所有的应用线程进入安全点，如果有一个线程一致没有进入，
            那么就会导致GC时JVM停顿时间边长。比如超大的循环导致执行GC前等待时间过长
        GC时，见擦汗或者保证所有的线程都跑到最近的安全带你停下来了？有两种方式：
            抢占式中断
                在需要GC时，先终端所有用户线程，判断用户线程是否停在安全电商。入股哦没有到达安全点的位置，则恢复线程让其运行到安全点的位置
            主动式中断
                在需要GC时，不直接中断所有用户线程，而是通过设置一个标志位表示马上需要执行垃圾回收了。当用户线程运行到安全点时，主动轮询整个标志位
                    如果中断标志为真，则自动中断挂起
        Safe Point机制保证了用户线程在执行，不需要等待太长时间就会遇到可进入的安全点位置。但是如果遇到用户程序不执行的情况，比如线程处理Sleep或者
            Blocked的状态。此时用户线程无法继续执行到下一个安全点，无法响应JVM的中断请求。
            如果等待线程唤醒，那等待的开销就太大了。这种情况需要用安全区域来解决
    安全区域：
        在一段代码种，对象的引用关系不会发生便哈，那么在这个区域种的任何位置喀什执行垃圾回收倒是安全的。
            可以将安全区域看作被扩展了的安全点
        当用户线程进入安全区域后会标志自己进入安全区域。JVM在进行垃圾收集时，会忽略安全区域状态的线程；
            当用户线程给你即将离开安全区域时，会检查JVM是否或者正在进行垃圾回收，如果不是那么用户线程继续执行，否则它将等待可以安全离开Safe Region的信号（比如垃圾回收完成）

什么是垃圾
    再也没有任何指针指向某个对象，那么这个对象就可以认为是垃圾
为什么会回收垃圾
    如果不回收，堆空间会被消耗殆尽。
    垃圾回收除了能释放没用外，还能清楚内存的记录碎片。碎片整理会把所占用的堆内存空间统一移动到堆的一端，一边腾出腾达的连续空间
Java垃圾回收
    一个良好的Java程序应该对应如下的收集频次：
        频繁回收年轻代
        较少回收老年代
        基本不动永久代
垃圾回收算法
    常见的垃圾回收算法有：
        引用计数法
        可达性分析法
        标记清除法
        标记压缩法
        复制算法
        分代收集法
        增量收集算法
    主要分为两个阶段
        标记阶段
            堆内存中存放着所有的对象实例，执行GC前，首先要区分出哪些对象是存活的，哪些是四万改的。
                只有标记为四万改的对象才能在垃圾回收时被回收。
                标记内存种死亡对象的过程被称为垃圾标记阶段
                如果一个对象已经不再被任何存活的对象应用，就可以判定为死亡
            引用计数法
                对每个对象保存一个整型的引用计数器属性，用户记录被对象引用的情况
                优点：
                    实现简单、判定效率高、回收没有延迟性
                缺点：
                    单独字段存储计数器的值，增加了额外的开销
                    每次变量复制都要更i性能引用计数器的值，加法和减法的操作增加了时间开销
                    无法处理循环引用问题。正是这一致命缺陷，导致引用计数器法没有应用在Java的垃圾回收器中
                        正是这一缺点，
            可达性分析法
                可达性分析不仅具备计数算法那样的实现简单、执行高效的优点，更重要的是该算法可以有效地解决循环引用的问题，避免内存泄漏的发生
                Java语言选择的就是可达性分析算法，这种类型的垃圾收集也成为：追踪行垃圾回收、根搜索算法
                可达性分析的思想：
                    可达性分析算法是以跟对象集合（GC Roots）为起点，按照自顶向下的方式搜索被根对象集合所连接的目标对象是否可达
                    使用可达性分析之后，内存中存货对象都会被GC Roots集合中的对象直接或间接的连着。搜索走过的路径被称为引用链（Reference Chain）
                    如果目标对象没有任务引用链项链，则是不可达的，可以标记为垃圾对象
                    只有被根对象集合直接或者间接连接的对象才能是存活对象
                    所谓根对象集合就是一组活跃的引用
                GC Roots包含以下元素
                    虚拟机栈中引用的对象。比如个西安测绘给你被调用的方法中使用到的参数、局部变量等
                    本地方法栈中的JNI（本地方法）引用的对象
                    方法区中类的静态属性引用的对象。比如Java的静态类型的引用变量
                    方法区中常量引用的而对象，比如字符串常量池中的引用
                    所有被同步监视器synchronized持有的对象
                    JVM内部的引用。比如基本数据类型对象的Class对象，一些常驻的异常对象，如：NullPointerException,OutOfMemoryError,系统加载器
                    反应JVM内部情况的JMXBean，JVMTI中注册的回调、本地代码缓存
            除了上述规定的GC Roots外，根据用户所选择的垃圾收集器以及当前内存区域的不通，还有有其他临时性的加入，共同构成完整的GC Roots集合。
                比如分带收集和局部收集（Partial GC）
            有一个识别GC Root的技巧。由于Root采用栈方式存放变量和指针，所有如果一个指针指向了堆内存的对象，而其自身又不在堆内存里，那它就是ROOT
            注意：
                如果使用可达性分析算法来标记某个对象是否可以被回收，那么整个分析工作必须在一个能保证一致性的快照中进行。
                    否则分析结果准确性就无从保证。这也是GC时候Stop The World的一个重要原因。
                    即使在号称几乎不会发生GC停顿的CMC收集器中，枚举根节点时，也是要停顿的
            关于GC溯源
                有一些性能分析工具比如MAT和Jprofiler可以帮助我们进行GC溯源，即标志出从当前对象到GC Roots的路径。
        清除阶段
            当成功标记处内存中存活的对象和死亡对象后，垃圾收集器就要执行回收任务，释放无用对象所占用内存空间，一边有足够用的内存空间分配给新的对象
            标记-清除法（Mark-Sweep）
                当堆内的有效空间被耗尽时，就会停止整个应用程序（通常称为Stop the world）,然后进行两项工作，标记和清除
                标记：
                    从引用根节点开始便利，标记所有被引用的对象。一般是在对象的Header中标记为可达对象
                清除：
                    对堆内存从头至尾进行线性遍历，如果发现某个对象在其header中没有标记为可达对象，则将其回收
                缺点：
                    先行遍历的效率不高，且GC时需要停止整个应用程序，导致用户体验差
                    清理出来的空闲内存时不连续的，产生了内存碎片，需要额外维护一个空闲列表
                注意：
                    这里所说的清除并不是真正的置空，而是把需要清除的对象的内存地址保存在空闲地址的列表中
                    下次有新的对象需要分配空间时，判断原来及的位置，空间是否足够，够就存放
            复制算法（Copying）
                复制算法的思想
                    将空闲的内存空间分为两块，每次只是用一块。在垃圾回收时将正在使用的内存空间中的存活的对象复制到未被使用的内存块中，
                    之后一次性清除正在使用的内存块中的所有对象，交换两块内存的角色，最终完成垃圾回收
                复制算法的优缺点
                    优点：
                        回收阶段美欧标记和清除的过程，实现简单，运行搞笑
                        复制转移的方式能够保证空间的连续性，不会出现碎片化问题
                    缺点：
                        空间开销大，需要两倍的内存空间
                        对于一些需要拆分为大量的regin的垃圾回收器，如g1,复制而不是移动，意味着垃圾收集器需要维护region之间的对象引用关联
                            内存占用和时间开销都很高
                        如果垃圾对象少，来回复制显得很低效。
                            因此复制算法适合系统中垃圾对象特别多的场景。这样需要复制的存活对象就不会太多。
                                比如年轻代的s0、s1的垃圾回收旧很适合此算法
                JVisualVM中，可以使用VisualGC插件可以动态展示内存各个区域的垃圾回收情况
            标记压缩法(Mark-Compression,Mark-Compact)
                复制算法的高效性是建立在存活对象少、垃圾对象多的前提下。满足这种情况的通常只有年轻代。
                而在老年代，常见的大部分都是存货对象。如果使用复制算法，由于存活对象较多，必然增加复制成本
                标记-清除算法也可以在老年代使用，但是由于本身的执行效率地下、会产生内存碎片的特点，因此也不适合直接使用。
                    所以JVM的设计者在次基础上改进出标记-压缩算法
                标记-压缩算法的思想
                    同标记清除一样，第一阶段，从根节点开始标记所有被引用的对象
                    垃圾清除的第二阶段将所有存活的对象压缩到内存的一端，按顺序存放
                    最后清理边界外的所有空间
                标记-压缩算法最终效果相当于标记-清除之后再做一次内存碎片的整理。因此也有人称为标记-清除-压缩算法
                    二者的差异在于标记清除是非移动的回收算法。而标记-压缩式移动式的，效率更高。
                        是否移动回收后的存活对象是一项优缺点并存的策略
                标记-压缩算法中，被标记的存活的对象会被压缩（整理），按照内存地址一次排列，而未被标记为存活的对象所占用的额内存会被释放掉
                当为新的对象分配内存内存空间时，JVM只需要持有一个内存的其实地址即可，这比标记-清除算法维护一个空闲列表开销小得多
                优缺点：
                    优点：
                        克服了标记-清除算法的内存区域分散缺点，当需要给新的对象分配内存时，JVM只需要持有一个内存的其实地址即可
                        避免了复制算法中内存使用率减半的昂贵代价
                    缺点:
                        标记-压缩算法的执行效率要低于复制算法
                        如果再移动存活对象时，该对象被其他对象引用，那么还需要调整引用的地址
                        移动过程中需要stop the world
                算法对比：
                            标记清除        复制算法        标记整理
                    速度：     中等              快           慢
                    空间开销：   少（碎片）       大（无碎片）      少（无碎片）
                    移动对象：   否           是               是

    分代收集
        没有最好的算法，只有最合适的算法
        分代算法并没有创造新的算法，而是对已有的算法组合使用
        基于：
            不同对象的声明周期是不一样的，因此具有不同声明周期特点的对象可以采用不同的垃圾回收方式，以提高整体的回收效率
            在Java中，堆内存分为新生代和老年代。因此，可以根据各个内存分区的特点是用不同的垃圾回收算法
        目前，Java中几乎所有的垃圾回收器都采用的分代收集的方式，基于分代的概念，垃圾收集器所使用的回收算法必须结构和年轻代和老年代的特点，才能发挥最大的小效率
            年轻代：
                年轻代的区域大小相对于老年代要小，对象朝生夕死，生命周期短，存活率低，回收频繁
                这种情况下，复制算法的效率和当前存活的对象和大小有关，因此适合在奶奶清代回收。
                    而针对复制算法内存利用率不高的缺点，在Hotspot中采用了两个幸存者区（s0,s1）的设计得以改进
            老年代：
                老年代的区域比较大，对象存活时间长，回收频率不及年轻代
                    这种大量存活对象的情况下不适合使用复制算法。一般使用标记-清除或者标记-压缩混合的方式

        以CMS垃圾回收举例，CMS是基于Mark-Sweep实现的。对于碎片的问题，CMS采用预计Mark-Compact算法的Serial Old收集器作为补偿；
            当堆内存回收不佳时，将采用Serial old收集器执行Full GC以达到堆老年代的整理

        分带收集的思想已经被现有虚拟机普遍采用。近乎所有的垃圾回收及都区分新生代和老年代

    增量收集算法
        为了应对STW问题，出现了增量收集算法
        基本思想：
            每次垃圾收集线程只收集一小部分区域的内存空间，紧接着切换到应用程序线程执行。如此反复，知道垃圾收集完成
            并没有创造新的算法，还是基于基础的标记-清楚和复制算法，只是通过线程冲突妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或者复制工作
        缺点：
            回收过程中，间断执行了应用和层序的代码，所有可以降低用户程序的停顿时间。
                但是由于线程切换导致的上下文切换开销，是的垃圾回收的总体册灰姑娘本上升，造成一定程度上的系统吞吐量的下降
    分区算法：
        同等条件下，JVM管理的堆内存越大，一次垃圾回收所需要的时间旧越长，GC停顿的时间旧越长。
        为了更好的控制GC停顿时间，可以将一块较大的内存区域分割为多个小的内存块。
        根据设置目标停顿时间，你每次合理地回收若干个小的空间，而不是整个堆，从而减少一次GC所产生的停顿时间。

        与分带算法按照独享的生命周期来划分不同的代不同，分区算法将整个堆空间哈芬威连续的不同的小区间。
            每一个小区间都独立使用，独立回收。可以根据设置的GC目标停顿时间控制一次回收多少个小空间

常见的垃圾回收器
    分类：
        线程数：
            串行垃圾收集器
                同一时间，只允许一个CPU用于执行垃圾回收线程
            并行垃圾收集器
                多个CPU同时进行垃圾回收，其停顿往往小于串行，因此提升了吞吐量
        工作模式：
            并发式
                垃圾回收和应用程序可以交替进行，尽可能较少垃圾回收时应用程序的停顿
            独占式
                垃圾回收线程执行需要stop the world，用户线程全部暂停，知道垃圾回收结束
        碎片处理方式
            压缩垃圾回收
                对存活对象压缩整理，消除回收后的额内存碎片
            不压缩垃圾回收
                不进行碎片整理
        工作的区域分
            年轻代
            老年代
    性能指标
        吞吐量
            用户代码时间占总运行使劲按的比例。总的运行时间=用户程序运行时间+垃圾回收时间
        暂停时间
            执行垃圾回收时，程序的工作线程被暂停的时间
        收集频率
            垃圾收集操作发生频率
        内存占用
            推内存所占用的大小
        通常高吞吐量和低延迟时间式垃圾收集器追求的目标。但是通常不同时具备。
            通常在保证族弟啊吞吐量的情况下，价格年底停顿时间
            吞吐量优先：单位时间内，STW的时间最短
            低延迟优先：单词STW时间最短
    常用的垃圾收集器
        串行：Serial、Serial Old
        并行：ParNew、Parallel Scavenge、Paralel Old
        并发：CMS、G1

        新生代：Serial、ParNew、Parallel Scavenge
        老年代：Serial Old、 Parallel Old、CMS
        整堆：G1
    Serial收集器
        新生代采用复制
        老年代采用标记压缩
        都是串行的
        可以和新生代的Parallel Scavenge收集器配合，也可以作为老年代的CMS收集器的备份收集器
        特点：
            简单高效、单个cpu长ijng，serial没有多线程开销
            如果内存不大，较短时间内完成回收，也是个不错的溴铵则
        -XX:+UseSerialGC表示新生代使用Serial GC，老年代使用Serial Old GC
    ParNew
        本质上是Serial的多线程版本，除了并行的方式回收内存，ParNew和Serial收集器没有区别。
        年轻代同样采用复制算法
        对于新生代，由于频次高，并行的方式更加高效
        老年代，回收次数少，使用串行方式无需i西安城切换，更加节约系统资源
        -XX:+UseParNewGC 表示新生代使用ParNewGC，且不影响老年代
        -XX:ParallelGCThread 设置GC线程的数量，默认等于核数

    Parallel
        Parallel Scavenge收集器是既ParNew收集器后有一块并行收集器。也是复制算法，并行回收，以及”Stop The World“
        和ParNew不同的是，Parallel Scavenge是一个吞吐量优先的收集器，他的目标是达到一个可控制的吞吐来个呢。
            此外，Parallel Scavenge收集器还有自适应的调节策略
        所谓高吞吐量，就是高效利用CPU的时间，尽快完成程序的计算任务，主要适合在后台运行而无需太多交互的场景。
            比如说，批处理、科学计算等应用，非常适合在这样的服务器环境中使用。
        Parallel Old收集器，可以用来替代串行的Serial Old收集器。
            Parallel Old收集器采用了标记压缩算法，基于并行回收和STW机制
        在吞吐量优先的应用场景中，Parallel Scavenge收集器和Parallel Old收集器的组合在HotSpot的Server模式下有着不错的性能。
            因此在JDK8中，默认的垃圾收集器组合就是它
        常用参数：
            -XX:+UseParallelGC 指定使用Parallel Scavenge收集器收集年轻代
            -XX:+UseParallelOldGC 指定使用ParallelOldGC收集器收集老年代
            （上面两个参数只要开启一个，另一个就会默认开启，他们相互激活）
            -XX:+ParallelGCThreads 设置年轻代并行收集器的数量（一般与CPU数相等）
            特别的参数：
                -XX:MaxGCPauseMillis 设置垃圾收集器的最大停顿时间，即STW的最大时间，单位是毫秒
                为了达到控制停顿时间的目的，Parallel Scavenge收集器在工作时会调整JAVA堆的带下以及其他的一些参数。一般不设置
                -XX:GCTimeRatio
                    设置垃圾回收时间和总时间的比例，范围时（1-100），默认时99，即执行垃圾回收的时间不超过1%
                -XX:+UseAdaptiveSizePolicy
                    如果开启，默认时开启，年顶戴的大小、Eden区和Survivor的比例、晋升老年代的年龄参数等都被自动调整，以达到推大小、吞吐量停顿时间之间的平衡
    CMS收集器
        CMS(Concurrent-Mark-Sweep)是1.5推出的。第一块并发收集器，首次实现了用户线程和垃圾收集线程同时工作
        主要关注尽可能缩短垃圾回收时用户线程的停顿时间、停顿时间越短，旧约适合和用户频繁交互的场景。
            一些网站的后端系统，比较重要服务的响应速度，希望系统停顿时间最短，以达到最好的用户体验
        CMS收集器是工作与老年代的收集器，采用的是标记-清除蒜贩，并也会stop the world
        无法与Parallel Scavenge收集器配合，因此CMS，新生代只能选择ParNew或者Serial收集器。
            G1出现之前，CMC使用很广泛，今天要也是

        CMS的整个执行过程较之前的收集器而言，相对复杂。分过四个阶段:初始标记、并发标记、重新标记、并发清除
            初始标记：
                整个阶段程序中所有的工作线程都会由于STW机制而出现短暂的停顿
                    这个阶段主要就是标记处GC Roots的元素能直接关联到的对象。一旦标记完成就会恢复之前被暂停的应用线程。
                    这个过程非常快
            并发标记
                从GC Roots直接关联的对象开始遍历整个对象图，整个过程比较长但是无需停顿用户线程，可以和垃圾回收线程同时执行或者交替执行
            重新标记
                由于并发标记二阶段用户线程回和垃圾回收线程同时运行或者交替运行，为了修正整个阶段因瀛湖线程的运行而导致标记产生变动的那部分对象的标记记录
                    因为需要重新标记。重新标记阶段的停顿时间通常回避初始标记稍长，但远比并发标记阶段要短
            并发清除
                此阶段清理掉标记阶段判断为已经死亡的对象，并释放内存空间。由于不需要移动存活对象，所以整个阶段无需停顿用户线程，GC线程可以与用户线程并发执行

            尽管CMS是并发回收，但是在其初始化表姐和重新表阶段还是由于 Stop The World机制，要在那听用户线程。只不过暂停时间较短

            由于CMS中，最耗时的并发标记和并发清除都可以和用户线程并行，不需要暂停给用户下称，因此整理的回收时低延迟的

            由于CMS上述过程中没有在那听用户线程，因此需要确保在CMS运行过程中有足够的内存可以供线程使用
            CMS不会像其他的回收器那养等到老年代几乎不可用时才会进行垃圾收集，而时当堆内存使用率达到一定阈值（最好手动设置）之后开始进行回收，
            以确保CMS工作过程以然有足够的内存空间供应用程序运行。
            如果CMS执行期间预留的内存无法满足应用程序的需要，就会导致Concurrent Mode Failure。此时虚拟机启动后背机制：临时启用Serial Old来进行老年代的收集，
            这会导致停顿时间变长

            CMS使用的是标记-清除算法，这就意味着，每次会收回，可能产生内存碎片。那么CMS在给新的对象分配空间时将无法使用指针碰撞计数，而只能使用空闲列表执行内存分配

            为什么不使用标记整理算法
                并发清除阶段，如果使用Compact算法整理内存的话，原来的用户线程使用的内存就会收到影响，要保证用户线程能够运行，前提是其运行资源不受影响。
                    因此标记整理算法不合适，标记整理更适合需要Stop The World的场景
            CMS收集器的优点：
                鬓发整理，低延迟
            CMS收集器的缺点：
                产生内存碎片
                    并发清除之后，yoghurt线程可用的内存不足，无法分配大对象的情况下，会提前触发Full GC
                对CPU比较敏感
                    并发阶段，虽然不会暂停用户线程，但是会占用一部分线程而导致应用程序变慢，总的吞吐量降低
                无法处理浮动垃圾
                    由于在并发标记阶段垃圾收集西安测绘给你和用户线程同时执行或者交替执行，可能在并发标记阶段又产生新的垃圾对象，CMS无法对这些垃圾对象进行标记
                        导致这些对象没有及时回收，而只能在下一轮执行垃圾回收是才能被释放
                可能出现Concurrent Mode Failure而导致另一次Full GC
                    应用程序启动时候，可以使用JVM参数指定CMS收集器
                        -XX:+UseConcMarkSweepGC指定使用CMS收集器收集老年代
                        上述参数会自动开启-XX:+UseParNewGC，即使用ParNew(Young)+CMS（old）+Serial Old的组合
                        -XX:CMSInitiatingOccupanyFraction:设置对内存使用率的阈值，一旦达到此阈值旧开始回收。
                            jdk5默认是68，6开始是92，建议可以适当调小，今早触发回收
                        如果应用程序的内存使用增长缓慢，则可以设置一个较大的值。大阈值可以有效降低CMS的触发次数。减少老年代的垃圾回收次数可以改善应用和层序的性能
                            反之，如果应用和层序使用内存的增长率很快，则一共降低此阈值，今早触发老年代的回收，以避免降级为老年代使用Serial Old收集器
                        -XX:+UseCMSConpactAtFullCollection：指定在之心玩Full GC之后对内存空间进行压缩整理。由于碎片整理的过程中无法和应用程序并发执行，所以会导致停顿时间变长
                        -XX:CMSFullGCBeforeCompaction:设置在发生多少次Full GC之后，对内存空间进行压缩整理
                        -XX:ParallelCMSThreads:设置CMS执行时的西安测绘给你书。CMS默认启动的线程时（ParallelGCThreads+3）/4ParallelGCThreads是年轻代的收集器线程数
        如何选择垃圾回收器
            最小化地使用内存以及降低并行开销，选择Serial GC
            最大化应用程序的吞吐量，使用Parallel GC
            最短的停顿时间，使用CMS GC

    G1垃圾回收器
        随着业务规模的不断增长，用户、数据越来越大，应用程序复杂西也越来越高。G1应运而生
        概述：
            G1(Garbage-First)是jdk7引入的一个新型的垃圾收集器，吸收了众多前沿研究成果，当时是最现金的。
            G1在机器内存不断扩大、处理器数量不断增长的大背景之下。这种场景下需要能够进一步地降低停顿时间，同时保持良好的吞吐量。
            因此G1肩负着解决上述问题的众人，是一个全功能的收集器
        设计思想：
            G1将内存空间分为多个不相关的区域（Region）,使用多个不同的Region表示Eden区、s0、s1、Old区。
            G1会有嘉华的而避免再整个Java堆中进行全区域的垃圾收集，而是会跟踪各个Region里面的垃圾回收的价值（回收所获得空间的大小以及回收素所需时间的经验值）
                再后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的Region。
            由于这种方式侧重于回收大量的垃圾区域，因此被称为垃圾优先

            一个Region可能属于Eden区、S区或者Old区。空白区表示未使用
            G1增加了要给Humogous的内存区域，主要用于存储大对象.比如超过1.5个Region就放到H区。
                如果一个H区放不下，就会找连续的H区存放，为了能够找到连续的H区，不得不启动Full GC。
                因此G1大多数是将H区作为老年代的一部分来看代
            G1主要针对配备了大容量内存何多喝CPU的机器，它以极大的概率满足GC停顿额时间要求，同时兼顾高吞吐量的性能指标
            jdk9开始，G1称为默认的垃圾回收器。但是jdk8中，默认的是Parallel Scavenge(Young)+Parallel Old(Old)，
                因此使用G1的话需要手动指定-XX:UseG1GC

        G1回收器的特点：
            并行与并发
                并行：回收阶段可以有多个GC线程同时工作，充分利用多核
                并发：支持垃圾回收线程和用户线程交替执行
            分代收集
                G1依然属于分代新型的垃圾收集器，区分年轻代、老年代。但是从堆的结构上看，G1并不要求整个Eden区、年轻代或者老年代是连续的空间，也不要求各个区域是固定的大小
                G1将堆空间分为若干区域，这些区域包含了逻辑上的年轻代和老年代。和其他收集最大的不同点是：
                    G1是全堆收集，兼顾年轻代和老年代
            空间整合
                堆空间分为若干区域，内存回收是以Region为单位，Region采用是复制算法。
                但整体上可以看作是标记-压缩算法，这两种都可以避免内存碎片。这种特性更有利于程序长时间的运行，
                    在分配大对象时候时，不会因为无法找到连续的内存空间而提前触发GC。在大堆场景下，G1的优势更加明显
            可预测停顿时间
                建立可预测的停顿模型时间。能够控制在一个长度为M毫秒的时间片段内，消耗在垃圾手机上的二十件不超过N毫秒
                由于分区的原因，G1可以选择部分进行回收，缩小范围能够较好的控制全局停顿情况
                G1垃圾回收优先的原则，即在允许的收集时间内，优先回收价值最大的Region。保证了G1的收集效率
            CMS比较
                G1未必能够做到CMS下最好情况的停顿延迟，但是最差的情况要比CMS好些。
                    因此G1对于CMS不具备的压倒性的优势。
                    从实际经验来看，CMS更适合小一点的内存，而G1适合在大内存上发挥优势。平衡点可以参考6~8G
        G1回收器的参数设置
            -XX:+UseG1GC 手动指定G1收集器
            -XX:G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围在1~32M之间
                G1会将Java堆哈芬为2048个大小相同的Region，每个Region的大小根据堆空间的实际大小而定，整体控制在1-32之间
                一旦设定，所有的Region大小相同，且在JVM的生命周期内不会改变
            -XX:MaxGCPauseMillis 设置期望达到的最大GC停顿时间，默认时200ms
            -XX:ParallelGCThread 设置STW的GC线程数，最大不超过8
            -XX:ConcGCThreads 设置并发标记的i西安成熟。一般设置为并行垃圾回收线程数的1/4
            -XX:InitiatingHeapOccupancyPercent 设置触发GC的堆内存的占用率。默认时45，超过45老年代才会并发标记
            G1的设计原则就是简化JVM性能调优，这也是JVM性能调优的大趋势
            三步调优：
                启用G1
                设置最大堆内存
                设置最大可容忍的停顿时间
        G1回收器回收过程
            年轻代回收
            老年代并发标记
            混合回收
            应用程序分配内存时候，当年轻代的Eden区用尽开始年轻代的回收；
                G1采用并行独占式收集方式，即暂停所有用户线程，启动多线程进行垃圾回收。然后从年轻代区间移动存活对象到S区或者老年代
            当堆内存达到45%时，开始老年代的并发标记
            标记完成之后开始混合回收的过程。
                G1从老年代移动存活对象到空闲区与，这些空闲区与也就称为老年代的一部分。
                G1老年代的回收和其他不同，不需要收集整个老年代，一次只需要回收部分老奶奶带的Region
                    同时整个老年代和新生代一起被回收
            各阶段细节
                年轻代
                    JVM启动时，G1先准备好年轻代的Eden区，应用和层序运行过程中不断拆给你佳能对象放到Eden
                    Eden区域耗尽时，G1启动一次年轻代的垃圾回收。
                        年轻嗲的税后知会收集Eden和Survivor区
                        回收时候会STW，创建一个回收集，回收集是指需要被回收的内存分段的集合。
                        年轻到回收集包括Eden和Survivor区的所有内存分段
                    （1）扫描根。
                        扫描所有的GC Roots，其作为扫描存活对象的入口
                    （2）更新Remember Set。
                        处理dirty card queue中的card，更新Rset.
                        该阶段完成后，RSet可以准确反应老年代中内存分段中的对象引用
                    （3）处理Remember Set
                        识别被老年代中的对象指向Eden区的对象，这些对象被认为是存活的对象
                    （4）复制对象
                        使用复制算法将Eden区中的存货独享复制到S区，同时对象的年龄+1，如果道道一定该阈值，将会复制到Old区中的内存分段中。
                            如果S区空间不足，Eden区中部分数据直接晋升老年代
                    （5）应用处理
                        处理Soft，Weak,Phantom,Final等引用。最终Eden为空，GC完成
                        Eden区变成空之后，就变成了无主Region，因此会被记录到空闲列表中，等待下一次分配
                老年代并发标记
                    初始标记
                        标记从根节点直接可达的对象，改阶段是STW的，并且会触发一次年轻代的GC
                    根区扫描
                        扫描S区直接可达的老年代区域对象，并标记为被引用的对象。
                            这一过程在YoungGC之前完成。
                            主要扫描哪些老年代对象是可达的，毕竟我们进行YoungGC的会移动，移动之后就找不到哪些老年代对象是可达的了
                    并发标记
                        在整个堆中进行并发标记，此过程可能被Young GC中断。
                            在并发标记阶段若发现区域中所有的对象都是垃圾，那么整个区域会立即回收。
                            同时，在并发标记国策和观念中会计算每个区域存活对象的比例
                    再标记
                        由于应用程序并发执行，因此需要修正上一次的标记结果
                    独占清理
                        计算每个区域存活对象以及GC回收的比例，并进行并排序，识别可以进行混合回收的区域。
                            为真正的清理做准备。这一步一个统计计算过程，不会涉及垃圾清理
                    并发清理
                        是被并清理空闲区域。如果发现区域对象中的所有对象都是垃圾，那么这个区域会被立即回收
                混合回收
                    越来越多的对象晋升到老年代后，为了避免内存耗尽，G1会触发一个混合垃圾收集，即Mixed GC。
                    除了回收整个Young之外，还会回收一部分Old。可以根据堆时间的要求选择性的回收某些Old Region。
                    Mixed GC不等同于Full GC
                可选的Full GC
                    G1收集器的初衷就是避免FullGC的出现，但是一些情况下还是可能触发Full GC
                        当G1在复制存活对象，没有空闲的内存分段可用，没有足够的空寂爱你存放晋升的对象，就会回退到Full GC，可以通过增大堆内存空间解决
                        并发处理完成之前空间耗尽。可以调小触发GC的Java堆占用阈值
                        最大GC停顿时间设置的太短，导致在规定的时间间隔内无法完成案例及回收，也会导致Full GC。
                            可以调大最大GC停顿时间解决
        G1收集器使用建议
            避免使用-Xmn或者-XX:NewRatio显示设置年轻代的大小
                因为固定年轻代的大小会覆盖掉停顿时间的目标。年轻代GC并行独占式的，所以最好让垃圾回收器自己去调节
            停顿时间不要设的太小
                G1收集器的目标是：应用程序时间：垃圾回收时间=9：1，即垃圾回收时间只占10%
                暂停时间和吞吐量是一对矛盾体，如果暂停时间的目标过于严苛，就会导致更多垃圾回收开销，甚至引起Full GC，从而影响吞吐量

        垃圾收集器小结
            https://bigbird.blog.csdn.net/article/details/120095591
        垃圾收集器选择建议
            如果堆内存小于100m，建议使用串行
            如果是单核、单机，对停顿时间不敏感，仅以使用串行
            如果是多CPU，追求高吞吐量，建议选择并行回收器
            如果是多CPU，与用户交互频繁，追求低延迟，建议选择并发回收器如CMS或者G1
            CMS和G1
                6g上使用G1，2-4g可选cms
                cms调优比较复杂，一般要调整堆内存使用率的阈值，建议设置为道道65%开始回收老年代
                优先考虑g1，指定JVM最大内存，剩下交给g1去解决

    方法区的垃圾回收
        内容常量池中废弃的常量和不再使用的类型
        常量池：
            没有任何地方应用，就可以回收
        类型：需要同时满足以下三个条件
            堆中不存在该类以及任何派生子类的类型
            加载该类的加载器被回收
            该类对象的java.lang.Class没有任何地方被引用

    类的卸载
        （1）启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)
        （2）被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。
        （3）被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到